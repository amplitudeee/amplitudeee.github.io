<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>System Development Practice Test</title>
  <style>
    /* Extravagant theme: gradients, glass cards, animated accents */
    :root{
      --bg-start:#0f2027;
      --bg-mid:#203a43;
      --bg-end:#2c5364;
      --card:#ffffff22;
      --accent1:#ff6b6b;
      --accent2:#f7b733;
      --accent3:#8e44ad;
      --glass-blur:8px;
    }

    html,body{height:100%;}
    body {
      font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      min-height:100%;
      /* layered gradients: make them cover, not tile, and fixed during scroll */
      background: radial-gradient(1200px 600px at 10% 10%, rgba(255,107,107,0.08), transparent 10%),
                  linear-gradient(135deg, var(--bg-start), var(--bg-mid) 40%, var(--bg-end));
      background-repeat: no-repeat, no-repeat;
      background-attachment: fixed, fixed;
      background-size: cover, cover;
      background-position: center center, center center;
      color: #fbfbff;
      display:flex;
      justify-content:center;
      padding:40px 24px;
    }

    /* Page card */
    .page {
      position: absolute;
      z-index: 2;
      width: min(1100px, 96%);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border-radius: 18px;
      padding: 28px;
      box-shadow: 0 10px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
      backdrop-filter: blur(var(--glass-blur));
      border: 1px solid rgba(255,255,255,0.04);
      overflow: visible;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Ensure page children sit above backdrop */
    .page > * { position: relative; z-index: 2; }

    h1, h2 { color: #fff; text-shadow: 0 2px 12px rgba(0,0,0,0.6); }

    .toggle-bar {
      display:flex;
      gap:12px;
      margin-bottom:22px;
      align-items:center;
    }

    /* Fancy buttons */
    button {
      border: none;
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      color: #0b0b0b;
      font-weight: 700;
      letter-spacing: .3px;
      transition: transform .18s ease, box-shadow .18s ease;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
      background: linear-gradient(90deg,var(--accent1),var(--accent2));
    }

    button#btnShowB { background: linear-gradient(90deg,#6a11cb,#2575fc); color:#fff; }
    /* removed btnToggleMode style (button removed) */

    button:hover{ transform: translateY(-3px) scale(1.02); box-shadow: 0 10px 28px rgba(0,0,0,0.45); }
    button:disabled{ opacity:.5; cursor:not-allowed; transform:none; box-shadow:none; }

    /* Questions as glass cards */
    .question {
      margin-bottom: 16px;
      padding: 16px 18px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      box-shadow: 0 8px 20px rgba(12,20,30,0.45);
      transition: transform .18s ease, box-shadow .18s ease;
    }

    .question:hover{ transform: translateY(-6px); box-shadow: 0 18px 40px rgba(12,20,30,0.55); }

    .question p{ margin:0 0 10px; color:#f6f7fb; font-weight:600; }

    input[type="radio"], input[type="checkbox"]{ accent-color: var(--accent3); transform: scale(1.08); margin-right:6px; }

    .answer {
      margin-top: 10px;
      font-weight: 800;
      color: #fff;
      padding: 12px 14px;
      border-radius: 10px;
      display:inline-block;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-left: 4px solid #f093fb;
    }

    .show-answer-btn {
      margin-top: 8px;
      margin-left: auto;
      margin-right: auto;
      padding: 6px 12px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(90deg, #3498db, #2980b9);
      color: #fff;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      transition: transform .18s ease, box-shadow .18s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: block;
      width: 50%;
    }

    .show-answer-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }

    .show-answer-btn:active {
      transform: translateY(0);
    }

    .correct { 
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
      color: #041a08;
      border-left: 4px solid #1abc9c;
    }
    .incorrect { 
      background: linear-gradient(135deg, #ff9a9e 0%, #ff6b6b 100%);
      color: #2b0606;
      border-left: 4px solid #e74c3c;
    }

    .hidden { display:none !important; }

    /* Dark mode tweaks */
    .dark-mode { filter: brightness(.96) saturate(.9); }

    /* Responsive tweaks */
    @media (max-width:700px){
      html, body { height: auto; }
      body { padding: 20px 12px; }
      .page { 
        position: absolute;
        width: 100%;
        padding: 16px;
        top: auto;
        left: 0;
        transform: none;
      }
      .card-backdrop {
        position: absolute;
        left: 0;
        width: 100%;
        transform: none;
      }
      .toggle-bar { 
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
      }
      button { 
        width: 100%;
        padding: 12px 10px;
        font-size: 14px;
      }
      .question {
        margin-bottom: 12px;
        padding: 12px 14px;
      }
      .question p {
        font-size: 14px;
        margin: 0 0 8px;
      }
      .answer {
        font-size: 13px;
        padding: 6px 8px;
        margin-top: 8px;
      }
      .form-actions {
        flex-direction: column;
        gap: 8px;
        margin-top: 16px;
      }
      h2 { font-size: 18px; }
      input[type="text"] { font-size: 14px; }
      label { 
        display: block;
        margin-bottom: 6px;
        font-size: 13px;
      }
    }

    /* Form actions (submit/reset) match top toggle spacing */
    .form-actions {
      display:flex;
      gap:12px; /* same gap as .toggle-bar */
      margin-top:22px;
      align-items:center;
      justify-content:flex-start;
      position: relative;
      z-index: 10;
    }
    .form-actions button {
      position: relative;
      z-index: 11;
    }

    /* Stylish progress bar */
    .progress { display:flex; align-items:center; gap:10px; margin: 8px 0 18px; }
    .progress-track { flex:1; height:10px; border-radius:999px; background: rgba(255,255,255,0.12); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); overflow:hidden; }
    .progress-fill { height:100%; width:0%; background: linear-gradient(90deg,#6a11cb,#2575fc); border-radius:999px; box-shadow: 0 0 12px rgba(37,117,252,0.6); transition: width .3s ease; }
    .progress-text { min-width:60px; font-weight:700; color:#eaf2ff; text-shadow: 0 1px 6px rgba(0,0,0,0.4); }

    /* Animated accents */
    .accents{ position:fixed; inset:0; pointer-events:none; overflow:visible; z-index:0; }
    .blob{
      position:absolute;
      width:260px; height:260px; border-radius:50%;
      filter: blur(40px) saturate(130%);
      opacity:0.55; mix-blend-mode:screen; transform: translate3d(0,0,0);
      animation: floaty 8s ease-in-out infinite;
    }
    .blob.b1{ left:6%; top:8%; background: radial-gradient(circle at 30% 30%, rgba(255,107,107,0.95), rgba(247,183,51,0.6)); animation-duration:10s; }
    .blob.b2{ right:8%; top:18%; width:320px;height:320px; background: radial-gradient(circle at 20% 20%, rgba(106,17,203,0.9), rgba(37,117,252,0.55)); animation-duration:12s; }
    .blob.b3{ left:20%; bottom:6%; width:200px;height:200px; background: radial-gradient(circle at 30% 30%, rgba(46,204,113,0.9), rgba(39,174,96,0.4)); animation-duration:9s; }

    @keyframes floaty{
      0%{ transform: translateY(0) scale(1) rotate(0deg); }
      50%{ transform: translateY(-18px) scale(1.06) rotate(6deg); }
      100%{ transform: translateY(0) scale(1) rotate(0deg); }
    }

    /* Shimmer for page heading */
    .shimmer {
      position:relative; overflow:hidden; display:inline-block;
    }
    .shimmer::after{
      content:''; position:absolute; top:0; left:-60%; width:40%; height:100%;
      background: linear-gradient(120deg, rgba(255,255,255,0), rgba(255,255,255,0.28), rgba(255,255,255,0));
      transform: skewX(-18deg);
      animation: shimmer 3.6s linear infinite;
      mix-blend-mode: overlay; pointer-events:none;
    }
    @keyframes shimmer{ 0%{ left:-60%; } 100%{ left:120%; } }

    /* Full-height translucent backdrop behind the page card (positioned by JS) */
    .card-backdrop{
      border-radius:18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      box-shadow: 0 10px 30px rgba(2,6,23,0.45);
      z-index:1; 
      pointer-events:none;
      backdrop-filter: blur(var(--glass-blur));
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Results Page Styling */
    .results-summary {
      text-align: center;
      margin: 24px 0;
      padding: 24px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .score-display {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
    }
    .score-number {
      font-size: 48px;
      font-weight: 800;
      color: #fff;
      text-shadow: 0 2px 12px rgba(0,0,0,0.6);
    }
    .score-percentage {
      font-size: 36px;
      font-weight: 700;
      color: #6a11cb;
      text-shadow: 0 2px 8px rgba(106,17,203,0.4);
    }
    .results-message {
      font-size: 24px;
      font-weight: 600;
      margin-top: 12px;
    }
    .results-details {
      margin: 20px 0;
    }
    .results-details h3 {
      color: #fff;
      margin-bottom: 16px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    .result-item {
      margin-bottom: 16px;
      padding: 14px 16px;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .result-item.correct {
      border-left: 4px solid #2ecc71;
    }
    .result-item.incorrect {
      border-left: 4px solid #e74c3c;
    }
    .result-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .result-icon {
      font-size: 20px;
      font-weight: 800;
    }
    .result-item.correct .result-icon {
      color: #2ecc71;
    }
    .result-item.incorrect .result-icon {
      color: #e74c3c;
    }
    .result-num {
      font-weight: 700;
      color: #aaa;
    }
    .result-question {
      color: #f6f7fb;
      margin-bottom: 8px;
      font-weight: 600;
    }
    .result-answer, .result-correct {
      color: #ddd;
      margin: 4px 0;
      font-size: 14px;
    }
    .result-answer strong, .result-correct strong {
      color: #fff;
    }
    .result-explanation {
      margin-top: 8px;
      padding: 8px 12px;
      background: rgba(106,17,203,0.15);
      border-radius: 8px;
      color: #d4d4ff;
      font-size: 13px;
      font-style: italic;
    }

    /* Intro page styles */
    .intro-page { margin-bottom: 24px; }
    .test-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
    }
    .test-option-card {
      padding: 18px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: 0 8px 20px rgba(12,20,30,0.45);
      transition: transform .18s ease, box-shadow .18s ease;
    }
    .test-option-card:hover { transform: translateY(-4px); box-shadow: 0 16px 32px rgba(12,20,30,0.55); }
    .test-type { color:#eaeaff; opacity: .9; margin-top: 4px; }
    .test-features { list-style: none; padding: 0; margin: 10px 0 16px; color:#ddd; }
    .test-features li { margin: 6px 0; }
    .start-test-btn { width: 100%; }
  </style>
</head>
<body>
  <div class="accents" aria-hidden="true">
    <span class="blob b1"></span>
    <span class="blob b2"></span>
    <span class="blob b3"></span>
  </div>
  <div class="card-backdrop" aria-hidden="true"></div>
  <div class="page">
  <!-- Intro Page -->
  <div id="introPage" class="intro-page">
    <h1 class="shimmer">System Development Practice Test</h1>
    <p style="text-align: center; margin-bottom: 24px; font-size: 18px; color: #ddd;">Choose your test format</p>
    <div class="test-options">
      <div class="test-option-card" id="optionA">
        <h2>Test A</h2>
        <p class="test-type">Multiple Choice & True/False</p>
        <ul class="test-features">
          <li>âœ“ 20 randomized questions</li>
          <li>âœ“ Multiple choice options</li>
          <li>âœ“ True/False questions</li>
          <li>âœ“ Instant feedback on each answer</li>
          <li>âœ“ Detailed explanations provided</li>
        </ul>
        <button class="start-test-btn" data-test="A" id="startTestA">Start Test A</button>
      </div>
      <div class="test-option-card" id="optionB">
        <h2>Test B</h2>
        <p class="test-type">Short Answer</p>
        <ul class="test-features">
          <li>âœ“ 20 randomized questions</li>
          <li>âœ“ Open-ended responses</li>
          <li>âœ“ Test your recall ability</li>
          <li>âœ“ Suggested answers provided</li>
          <li>âœ“ Comprehensive feedback</li>
        </ul>
        <button class="start-test-btn" data-test="B" id="startTestB">Start Test B</button>
      </div>
    </div>
  </div>
  
  <div class="toggle-bar" id="toggleBar" style="display:none;">
    <button id="btnShowA">Start Test A</button>
    <button id="btnShowB">Start Test B</button>
  </div>

  <!-- Optional: Plain-text question sources (easy to replace). One question per line. -->
  <script type="text/plain" id="sourceA">
Q1: Functional requirements define how a system should perform. | True | False
A1: False | Functional = what the system must do; the how is non-functional.

Q2: Non-functional requirements focus on how a system should perform. | True | False
A2: True | Non-functional defines how the system performs (quality attributes).

Q3: Functional requirements are not static and can be adjusted via structured processes. | True | False
A3: True | Functional requirements can be adjusted through change control or backlog refinement.

Q4: Change control is used in Agile to adjust the scope of functional requirements. | True | False
A4: False | Change Control is used in Waterfall; Agile uses Backlog Refinement.

Q5: Backlog refinement is used in Agile to adjust functional requirements. | True | False
A5: True | In Agile, backlog refinement adjusts the scope of functional requirements.

Q6: Performance, reliability, and security are examples of non-functional requirement aspects. | True | False
A6: True | These are all non-functional requirement aspects.

Q7: Portability and maintainability belong to Operational non-functional requirements. | True | False
A7: True | Portability and Maintainability are part of Operational non-functional requirements.

Q8: Availability and reliability are part of Performance non-functional requirements. | True | False
A8: False | Availability and Reliability are part of Operational requirements.

Q9: Access control and encryption are examples of Security non-functional requirements. | True | False
A9: True | Access Control and Encryption are Security non-functional requirements.

Q10: Laws and government regulations are part of Cultural & Political requirements. | True | False
A10: True | Laws and government regulations are Cultural & Political requirements.

Q11: Problem Analysis focuses on understanding â€˜whyâ€™ before â€˜whatâ€™. | True | False
A11: True | Problem Analysis identifies the business problem, focusing on 'why' first.

Q12: Root Cause Analysis focuses on symptoms rather than underlying issues. | True | False
A12: False | Root Cause Analysis digs into underlying causes, not just symptoms.

Q13: Duration Analysis looks at time taken for process activities to find efficiency opportunities. | True | False
A13: True | Duration Analysis examines time taken to identify efficiency opportunities.

Q14: Activity-Based Costing includes indirect costs as well as direct costs. | True | False
A14: True | Activity-Based Costing includes both direct and indirect costs.

Q15: Informal Benchmarking involves comparing processes with other businesses to improve. | True | False
A15: True | Informal Benchmarking compares processes with other businesses for improvement ideas.

Q16: Outcome Analysis ignores past results to avoid bias. | True | False
A16: False | Outcome Analysis uses past results to guide future actions.

Q17: Technology Analysis examines current environment and trends to inform investments. | True | False
A17: True | Technology Analysis looks at current tech environment and trends for investment decisions.

Q18: Activity Elimination targets nonâ€“value-adding activities to free resources. | True | False
A18: True | Activity Elimination removes nonâ€“value-adding activities to free up resources.

Q19: Open communication helps prevent team conflict. | True | False
A19: True | Open communication is key to preventing team conflict.

Q20: Effort estimation is not important for cost control. | True | False
A20: False | Effort estimation is crucial for cost control.

Q21: Which process adjusts functional requirements in Waterfall? | Change Control | Backlog Refinement | Scope Creep | Kanban
A21: Change Control | Change Control is the formal process in Waterfall for adjusting requirements.

Q22: Which non-functional category includes Availability? | Operational | Performance | Security | Cultural & Political
A22: Operational | Availability is part of Operational non-functional requirements.

Q23: Which analysis strategy identifies inefficient code as the cause of performance issues? | Problem Analysis | Root Cause Analysis | Duration Analysis | Outcome Analysis
A23: Root Cause Analysis | Root Cause Analysis digs deep to find the underlying cause of issues.

Q24: Which requirements gathering technique builds relationships with stakeholders? | Interviewing | Observation | Questionnaire | Document Analysis
A24: Interviewing | Interviewing builds relationships and gathers detailed information.

Q25: Who defines requirements? | Project Manager | Developers | Business Analysts and Stakeholders | Customers only
A25: Business Analysts and Stakeholders | Business Analysts work with Stakeholders to define requirements.

Q26: What does WBS stand for? | Work Breakdown Structure | Workflow Business System | Work Balance Sheet | Work Budget Strategy
A26: Work Breakdown Structure | WBS breaks down a project into smaller, manageable tasks.

Q27: Which are the three trade-offs of effort estimation? | Scope, Time, Cost | Speed, Reliability, Security | Skills, Morale, Rewards | Availability, Portability, Maintainability
A27: Scope, Time, Cost | The project triangle balances Scope, Time, and Cost.

Q28: What is scope creep? | Adding new requirements after project starts | Breaking down project tasks | Visualizing workflow | Estimating costs
A28: Adding new requirements after project starts | Scope creep is uncontrolled expansion of project requirements.

Q29: Which method visualizes work process and flow? | Kanban | WBS | Benchmarking | Shadowing
A29: Kanban | Kanban boards visualize workflow and help manage tasks.

Q30: High morale indicates what? | Team has jelled | Scope creep | Poor communication | Cost control
A30: Team has jelled | High morale means the team has bonded and works well together.

Q31: Which requirements gathering technique provides a comprehensive understanding of system functionalities and business processes? | Interviewing | Observation | Questionnaire | Document Analysis
A31: Document Analysis | Document Analysis provides comprehensive system and process understanding.

Q32: Which requirements analysis strategy involves looking at past results to guide future actions? | Outcome Analysis | Technology Analysis | Activity Elimination | Informal Benchmarking
A32: Outcome Analysis | Outcome Analysis examines past results to inform future decisions.

Q33: Which non-functional category includes Portability? | Operational | Performance | Security | Cultural & Political
A33: Operational | Portability is part of Operational non-functional requirements.

Q34: Which strategy involves analyzing the current technology environment and trends? | Problem Analysis | Technology Analysis | Duration Analysis | Activity-Based Costing
A34: Technology Analysis | Technology Analysis examines current tech environment and trends.

Q35: Which requirements gathering technique can scale to a large number of respondents? | Interviewing | Observation | Questionnaire | Shadowing
A35: Questionnaire | Questionnaires can efficiently gather input from many respondents.

Q36: Which strategy involves identifying all costs associated with a business activity? | Activity-Based Costing | Root Cause Analysis | Outcome Analysis | Duration Analysis
A36: Activity-Based Costing | Activity-Based Costing identifies all direct and indirect costs.

Q37: Which non-functional category includes Virus Control? | Operational | Performance | Security | Cultural & Political
A37: Security | Virus Control is part of Security non-functional requirements.

Q38: Which strategy involves comparing processes informally with other businesses? | Informal Benchmarking | Technology Analysis | Activity Elimination | Problem Analysis
A38: Informal Benchmarking | Informal Benchmarking compares processes with other organizations.

Q39: Which requirements gathering technique ensures design is centered around user needs? | Interviewing | Observation | Questionnaire | Document Analysis
A39: Observation | Observation ensures design is based on actual user behavior and needs.

Q40: Which factor is important when forming a project team? | Member availability and skills | Scope creep | Kanban | High morale
A40: Member availability and skills | Team formation requires matching member availability and skills to project needs.
  </script>
  <script type="text/plain" id="sourceB">
Q1: Define functional requirements and explain their purpose.
A1: Functional requirements define what a system must do, describing its core features and tasks.

Q2: Define non-functional requirements and explain their focus.
A2: Non-functional requirements focus on how the system performs, covering quality attributes like speed, security, and usability.

Q3: How are functional requirements adjusted in scope during a project?
A3: They are adjusted through structured processes such as change control (Waterfall) or backlog refinement (Agile).

Q4: Name two structured processes used to adjust functional requirements.
A4: Change control in Waterfall and backlog refinement in Agile.

Q5: List four aspects covered by non-functional requirements.
A5: Performance, usability, reliability, security, maintainability.

Q6: Which non-functional category includes Portability and Maintainability?
A6: Operational â€” includes portability, maintainability, technical environment, and system integration.

Q7: Which non-functional category includes Speed and Capacity?
A7: Performance â€” includes speed, capacity, availability, reliability.

Q8: Which non-functional category includes Access Control and Encryption?
A8: Security â€” includes system value, access control, encryption & authentication, virus control.

Q9: Which non-functional category includes Laws and Government Regulations?
A9: Cultural & Political â€” includes laws, government regulations, language differences, centralized vs local control.

Q10: What is the goal of Problem Analysis in requirements analysis?
A10: Problem Analysis identifies and articulates the business problem, focusing on 'why' before 'what'.

Q11: What is the goal of Root Cause Analysis?
A11: Root Cause Analysis identifies underlying causes of problems rather than just symptoms.

Q12: What does Duration Analysis examine?
A12: Duration Analysis examines the time taken for activities to find efficiency opportunities.

Q13: What does Activity-Based Costing include beyond direct costs?
A13: Activity-Based Costing includes indirect costs like rent, utilities, salaries, and marketing in addition to direct costs.

Q14: What is Informal Benchmarking used for?
A14: Informal Benchmarking compares processes with other businesses to identify areas for improvement.

Q15: What is Outcome Analysis used for?
A15: Outcome Analysis uses past results to guide future actions.

Q16: What is Technology Analysis used for?
A16: Technology Analysis examines current technology environment and trends to inform investment decisions.

Q17: What is Activity Elimination used for?
A17: Activity Elimination removes nonâ€“value-adding activities to free resources.

Q18: What is the main benefit of Interviewing as a requirements gathering technique?
A18: Interviewing provides in-depth understanding and builds relationships with stakeholders.

Q19: What is the main benefit of Observation as a requirements gathering technique?
A19: Observation provides real-world understanding of user behavior and reduces miscommunication.

Q20: What is the main benefit of Questionnaires as a requirements gathering technique?
A20: Questionnaires scale to large groups, provide quantitative data, and allow anonymity.

Q21: What is the main benefit of Document Analysis as a requirements gathering technique?
A21: Document Analysis provides comprehensive understanding of systems and identifies gaps efficiently.

Q22: What is Shadowing used for in requirements gathering?
A22: Shadowing involves following users to observe their work and uncover implicit requirements.

Q23: Who defines requirements in a project?
A23: Business analysts and stakeholders define requirements.

Q24: Who does the work after requirements are defined?
A24: Project managers and developers do the work after requirements are defined.

Q25: What does WBS stand for and what is its purpose?
A25: Work Breakdown Structure â€” decomposes a project into smaller components for clarity and scope management.

Q26: What are the three trade-offs of effort estimation?
A26: Scope, Time, Cost â€” the three trade-offs of effort estimation.

Q27: What is scope creep?
A27: Scope creep is adding new requirements after a project has started.

Q28: Why is open communication important in project teams?
A28: Open communication prevents team conflict and supports collaboration.

Q29: Why are skill sets important when staffing a project team?
A29: Skill sets ensure the team has the right expertise for tasks.

Q30: What does high morale indicate in a project team?
A30: High morale indicates the team has 'jelled' and is working well together.

Q31: What is a possible team motivation strategy?
A31: Rewards and recognition motivate teams and improve performance.

Q32: What does Kanban visualize?
A32: Kanban visualizes work processes and flow.

Q33: Why is effort estimation critical for cost control?
A33: Effort estimation is critical for cost control because it predicts resource needs and expenses.

Q34: What is an important consideration when forming a group project?
A34: Member availability and skills are important considerations when forming a group project.

Q35: Why is rewards and recognition important for team motivation?
A35: Rewards and recognition encourage motivation, engagement, and sustained performance.

Q36: What does Kanban help visualize in project management?
A36: Kanban helps visualize workflow, bottlenecks, and task progress.

Q37: Why is effort estimation critical for managing project costs?
A37: Effort estimation ensures accurate budgeting and prevents overspending.

Q38: What are two important considerations when forming a group project team?
A38: Member availability and skills â€” ensures tasks are covered and team balance is maintained.

Q39: Give an example of how Outcome Analysis might influence future software releases.
A39: Outcome Analysis might lead to more thorough testing if past releases caused support issues.

Q40: Explain how Activity Elimination can improve efficiency in a business process.
A40: Activity Elimination improves efficiency by removing tasks that add no value, freeing resources for useful work.
  </script>

 <!-- Test A -->
  <form id="testA" class="test hidden">
    <h2>Test A</h2>
    <div class="progress" id="progressA" aria-live="polite">
      <div class="progress-track"><div class="progress-fill" id="progressFillA"></div></div>
      <div class="progress-text" id="progressTextA">1 / 20</div>
    </div>
    <!-- Questions are generated from #sourceA; static markup removed -->

    <div class="form-actions">
      <button type="button" id="btnPrevA" class="nav-btn">Prev</button>
      <button type="button" id="btnCheckA" class="nav-btn">Check</button>
      <button type="button" id="btnNextA" class="nav-btn">Next</button>
      <button type="button" id="btnSubmitA">Submit Test A</button>
    </div>
  </form>

<!-- Test B -->
  <form id="testB" class="test hidden">
    <h2>Test B</h2>
    <div class="progress" id="progressB" aria-live="polite">
      <div class="progress-track"><div class="progress-fill" id="progressFillB"></div></div>
      <div class="progress-text" id="progressTextB">1 / 20</div>
    </div>
    <!-- Questions are generated from #sourceB; static markup removed -->

    <div class="form-actions">
      <button type="button" id="btnPrevB" class="nav-btn">Prev</button>
      <button type="button" id="btnCheckB" class="nav-btn">Check</button>
      <button type="button" id="btnNextB" class="nav-btn">Next</button>
      <button type="button" id="btnSubmitB">Submit Test B</button>
    </div>
  </form>

  <!-- Results Page -->
  <div id="resultsPage" class="test hidden">
    <h2 id="resultsTitle">Test Results</h2>
    <div class="results-summary">
      <div class="score-display">
        <div class="score-number" id="scoreNumber">0/20</div>
        <div class="score-percentage" id="scorePercentage">0%</div>
      </div>
      <div class="results-message" id="resultsMessage"></div>
    </div>
    <div class="results-details" id="resultsDetails"></div>
    <div class="form-actions">
      <button type="button" id="btnTryAgain">Try Again</button>
    </div>
  </div>
  <script>
// Answers object - populated dynamically by renderFromPlainText from sourceA
const answers = {};
// Short answer key - populated dynamically by renderFromPlainText from sourceB
const shortAnswerKey = {};

    function toggleTest(test) {
      // Hide all forms including results page
      document.getElementById('testA').classList.add('hidden');
      document.getElementById('testB').classList.add('hidden');
      document.getElementById('resultsPage').classList.add('hidden');
      // Hide intro page once a test is selected
      const intro = document.getElementById('introPage');
      if (intro) intro.style.display = 'none';
      // Ensure toggle bar is visible while testing (for switching after completion)
      const tb = document.getElementById('toggleBar');
      if (tb) tb.style.display = 'flex';
      
      // Hide the start buttons once a test is started
      const btnShowA = document.getElementById('btnShowA');
      const btnShowB = document.getElementById('btnShowB');
      if (btnShowA) btnShowA.style.display = 'none';
      if (btnShowB) btnShowB.style.display = 'none';
      
      // Reset the selected test
      const formId = 'test' + test;
      resetForm(test);
      
      // Show the selected test and reset to first question
      document.getElementById(formId).classList.remove('hidden');
      currentIndex[formId] = 0;
      showQuestion(formId, 0);
    }

    function submitTest(test) {
      const form = document.getElementById('test' + test);
      if (!form) return;
      const questions = form.querySelectorAll('.question');
      let correctCount = 0;
      let totalCount = questions.length;
      const details = [];

      questions.forEach((q, idx) => {
        const firstInput = q.querySelector('input');
        const inputName = firstInput ? firstInput.name : null;
        const questionText = q.querySelector('p')?.textContent || `Question ${idx+1}`;
        const rawAnswer = inputName ? (test === 'B' ? shortAnswerKey[inputName] : answers[inputName]) : null;
        const correctAnswer = rawAnswer ? String(rawAnswer).split('|')[0].trim() : null;
        let explanation = '';
        if (rawAnswer) {
          const parts = String(rawAnswer).split('|');
          explanation = parts.length > 1 ? parts.slice(1).join('|').trim() : (test === 'B' ? String(rawAnswer).trim() : '');
        }
        let userAnswer = "";
        let isCorrect = false;

        if (q.querySelector('input[type="radio"]')) {
          const selected = q.querySelector('input[type="radio"]:checked');
          if (selected) userAnswer = selected.value;
          isCorrect = userAnswer === correctAnswer;
        } else {
          const textInput = q.querySelector('input[type="text"]');
          userAnswer = textInput ? textInput.value.trim() : "";
          isCorrect = userAnswer.toLowerCase() === (correctAnswer || '').toLowerCase();
        }

        if (isCorrect) correctCount++;
        details.push({
          num: idx + 1,
          question: questionText,
          userAnswer: userAnswer || '(no answer)',
          correctAnswer: correctAnswer,
          explanation: explanation,
          isCorrect: isCorrect
        });
      });

      showResults(test, correctCount, totalCount, details);
    }

    function resetForm(test) {
      const form = document.getElementById('test' + test);
      if (!form) return;
      form.reset();
      // hide and clear answer boxes
      const answersEls = form.querySelectorAll('.answer');
      answersEls.forEach(a => {
        a.classList.add('hidden');
        a.textContent = '';
        a.style.display = 'none';
      });
    }

    let lastTest = 'A';
    function showResults(test, correctCount, totalCount, details) {
      lastTest = test;
      // Hide tests, show results
      document.getElementById('testA').classList.add('hidden');
      document.getElementById('testB').classList.add('hidden');
      document.getElementById('resultsPage').classList.remove('hidden');
      
      // Show the start buttons again after test completion
      const btnShowA = document.getElementById('btnShowA');
      const btnShowB = document.getElementById('btnShowB');
      if (btnShowA) btnShowA.style.display = '';
      if (btnShowB) btnShowB.style.display = '';
      // Keep toggle bar visible; allow user to start another test
      const tb = document.getElementById('toggleBar');
      if (tb) tb.style.display = 'flex';

      // Update title
      document.getElementById('resultsTitle').textContent = `Test ${test} Results`;

      // Calculate percentage
      const percentage = Math.round((correctCount / totalCount) * 100);

      // Update score display
      document.getElementById('scoreNumber').textContent = `${correctCount}/${totalCount}`;
      document.getElementById('scorePercentage').textContent = `${percentage}%`;

      // Set message based on score
      const messageEl = document.getElementById('resultsMessage');
      if (percentage >= 90) {
        messageEl.textContent = 'Excellent work! ðŸŽ‰';
        messageEl.style.color = '#2ecc71';
      } else if (percentage >= 80) {
        messageEl.textContent = 'Great job! ðŸ‘';
        messageEl.style.color = '#27ae60';
      } else if (percentage >= 70) {
        messageEl.textContent = 'Good effort! ðŸ’ª';
        messageEl.style.color = '#f39c12';
      } else if (percentage >= 60) {
        messageEl.textContent = 'Keep practicing! ðŸ“š';
        messageEl.style.color = '#e67e22';
      } else {
        messageEl.textContent = 'Review and try again! ðŸ“–';
        messageEl.style.color = '#e74c3c';
      }

      // Build detailed results
      const detailsEl = document.getElementById('resultsDetails');
      let detailsHtml = '<h3>Question Review</h3>';
      details.forEach(d => {
        const icon = d.isCorrect ? 'âœ“' : 'âœ—';
        const statusClass = d.isCorrect ? 'correct' : 'incorrect';
        detailsHtml += `
          <div class="result-item ${statusClass}">
            <div class="result-header">
              <span class="result-icon">${icon}</span>
              <span class="result-num">Question ${d.num}</span>
            </div>
            <div class="result-question">${d.question}</div>
            <div class="result-answer">Your answer: <strong>${d.userAnswer}</strong></div>
            ${!d.isCorrect ? `<div class="result-correct">Correct answer: <strong>${d.correctAnswer}</strong></div>` : ''}
            ${d.explanation ? `<div class="result-explanation">${d.explanation}</div>` : ''}
          </div>
        `;
      });
      detailsEl.innerHTML = detailsHtml;
    }

    // Attach event listeners to buttons (replace inline onclicks)
    document.addEventListener('DOMContentLoaded', function() {
      // Factory functions to build question HTML
      function createTFQuestion(qId, text){
        return `\n<div class="question">\n  <p>${text}</p>\n  <label><input type="radio" name="${qId}" value="True"> True</label>\n  <label><input type="radio" name="${qId}" value="False"> False</label>\n  <div class="answer hidden" id="ans-${qId}"></div>\n</div>`;
      }
      function createMCQuestion(qId, text, options){
        const optionsHtml = options.map(val => `  <label><input type="radio" name="${qId}" value="${val}"> ${val}</label>`).join('\n');
        return `\n<div class="question">\n  <p>${text}</p>\n${optionsHtml}\n  <div class="answer hidden" id="ans-${qId}"></div>\n</div>`;
      }
      function createShortQuestion(qId, text){
        return `\n<div class="question">\n  <p>${text}</p>\n  <input type="text" name="${qId}" style="width:100%">\n  <div class="answer hidden" id="ans-${qId}"></div>\n</div>`;
      }
            // If plain-text sources exist, render questions from them for easy editing
            function renderFromPlainText(formId, sourceId, type){
              const sourceEl = document.getElementById(sourceId);
              const form = document.getElementById(formId);
              if (!sourceEl || !form) return false;
              // Prevent double rendering of the same form
              if (form.dataset.rendered === '1') return true;
              const raw = (sourceEl.textContent || '').trim();
              if (!raw) return false;
              const lines = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
              // Strip Q#: and A#: prefixes from lines
              const cleanedLines = lines.map(line => line.replace(/^[QA]\d+:\s*/, ''));
              if (!cleanedLines.length) return false;
              // Preserve header, progress, actions
              const headerHtml = form.querySelector('h2')?.outerHTML || '';
              const progressHtml = form.querySelector('.progress')?.outerHTML || '';
              const actionsEl = form.querySelector('.form-actions');
              let html = `${headerHtml}\n${progressHtml}`;
              
              let qNum = 0;
              let skipNext = false;
              for (let i = 0; i < cleanedLines.length; i++) {
                if (skipNext) {
                  skipNext = false;
                  continue;
                }
                const text = cleanedLines[i];
                // Check if this line contains question options (has multiple | separators)
                const pipeCount = (text.match(/\|/g) || []).length;
                
                // For choice questions, look for pipes. For text questions, any non-empty line is a question
                const isQuestion = (type === 'choice' && pipeCount >= 1) || (type === 'text' && pipeCount === 0 && text.length > 0);
                
                if (isQuestion) {
                  // This is a question line
                  qNum++;
                  const qId = `q${qNum}`;
                  
                  if (type === 'choice'){
                    const parts = text.split('|').map(s => s.trim()).filter(Boolean);
                    const questionText = parts[0] || text;
                    const optsRaw = parts.slice(1);
                    const opts = optsRaw.length ? optsRaw : ['True','False'];
                    
                    html += opts.length === 2 && opts[0]==='True' && opts[1]==='False'
                      ? createTFQuestion(qId, questionText)
                      : createMCQuestion(qId, questionText, opts);
                    
                    // Check next line for answer
                    if (i + 1 < cleanedLines.length) {
                      const nextLine = cleanedLines[i + 1];
                      const nextPipeCount = (nextLine.match(/\|/g) || []).length;
                      // If next line has 1 pipe, it's the answer line
                      if (nextPipeCount === 1) {
                        const answerParts = nextLine.split('|').map(s => s.trim());
                        if (answerParts.length === 2) {
                          answers[qId] = answerParts[0] + ' | ' + answerParts[1];
                          skipNext = true; // Skip the answer line in next iteration
                        }
                      }
                    }
                  } else {
                    // Short answer question
                    html += createShortQuestion(qId, text);
                    // Check next line for answer
                    if (i + 1 < cleanedLines.length) {
                      const nextLine = cleanedLines[i + 1];
                      // Next line with content is the answer
                      if (nextLine.trim().length > 0) {
                        shortAnswerKey[qId] = nextLine;
                        skipNext = true; // Skip the answer line
                      }
                    }
                  }
                }
              }
              
              html += `\n${actionsEl ? actionsEl.outerHTML : ''}`;
              form.innerHTML = html;
              // Mark as rendered to avoid duplicates on subsequent calls
              form.dataset.rendered = '1';
              return true;
            }

            // Try to render from text sources; fallback to existing markup if not present
            // If sourceA is empty, extract Test A questions from existing HTML and collapse markup
            function migrateTestAIfNeeded(){
              const srcA = document.getElementById('sourceA');
              if (!srcA) return;
              const hasContent = (srcA.textContent||'').trim().length > 0;
              if (hasContent) return;
              const formA = document.getElementById('testA');
              if (!formA) return;
              const qEls = Array.from(formA.querySelectorAll('.question'));
              if (!qEls.length) return;
              const lines = qEls.map(q => {
                const text = (q.querySelector('p')?.textContent || '').replace(/^\s*\d+\.?\s*/, '').trim();
                const radios = Array.from(q.querySelectorAll('input[type="radio"]'));
                if (radios.length){
                  const opts = radios.map(r => (r.value||'').trim());
                  return [text, ...opts].join(' | ');
                } else {
                  return text;
                }
              });
              srcA.textContent = lines.join('\n');
            }
            migrateTestAIfNeeded();
            // Minimize both forms, then render from sources to remove static markup
            (function(){
              const formIds = ['testA','testB'];
              formIds.forEach(fid => {
                const form = document.getElementById(fid);
                if (!form) return;
                const headerHtml = form.querySelector('h2')?.outerHTML || '';
                const progressHtml = form.querySelector('.progress')?.outerHTML || '';
                const actionsHtml = form.querySelector('.form-actions')?.outerHTML || '';
                form.innerHTML = `${headerHtml}\n${progressHtml}\n${actionsHtml}`;
              });
            })();
            renderFromPlainText('testA','sourceA','choice');
            renderFromPlainText('testB','sourceB','text');
      
      // Use event delegation on document to catch all button clicks
      document.addEventListener('click', function(e) {
        const target = e.target;
        
        if (target.id === 'btnSubmitA' || target.closest('#btnSubmitA')) {
          e.preventDefault();
          e.stopPropagation();
          submitTest('A');
          return false;
        }
        
        if (target.id === 'btnSubmitB' || target.closest('#btnSubmitB')) {
          e.preventDefault();
          e.stopPropagation();
          submitTest('B');
          return false;
        }
      }, true); // Use capture phase
      
      const btnShowA = document.getElementById('btnShowA');
      if (btnShowA) btnShowA.addEventListener('click', function() { toggleTest('A'); });
      const btnShowB = document.getElementById('btnShowB');
      if (btnShowB) btnShowB.addEventListener('click', function() { toggleTest('B'); });
      // Intro page start buttons
      const startA = document.getElementById('startTestA');
      if (startA) startA.addEventListener('click', function(){ toggleTest('A'); });
      const startB = document.getElementById('startTestB');
      if (startB) startB.addEventListener('click', function(){ toggleTest('B'); });
      // Results page button
      const btnTryAgain = document.getElementById('btnTryAgain');
      if (btnTryAgain) btnTryAgain.addEventListener('click', function() {
        location.reload();
      });

      // (Removed) JSON import/export helpers and buttons
      // (Removed) Regenerate buttons and functions

      // Note: avoid redundant re-rendering to prevent duplicate question cards

      // Paging: show one question at a time per form
      const currentIndex = { testA: 0, testB: 0 };
      const autoAdvance = false; // auto-advance disabled: user must press Next to continue

      function showQuestion(formId, index){
        const form = document.getElementById(formId);
        if (!form) return;
        const questions = Array.from(form.querySelectorAll('.question'));
        const total = questions.length;
        if (!total) return;
        if (index < 0) index = 0;
        if (index >= total) index = total - 1;
        currentIndex[formId] = index;
        questions.forEach((q,i) => q.style.display = (i === index ? '' : 'none'));
        const prev = document.getElementById(formId === 'testA' ? 'btnPrevA' : 'btnPrevB');
        const next = document.getElementById(formId === 'testA' ? 'btnNextA' : 'btnNextB');
        const check = document.getElementById(formId === 'testA' ? 'btnCheckA' : 'btnCheckB');
        const isLast = index === total - 1;
        if (prev) { prev.disabled = index === 0; prev.onclick = function(){ prevQuestion(formId); }; }
        if (next) {
          next.textContent = 'Next';
          next.onclick = function(){ nextQuestion(formId); };
          next.disabled = isLast;
        }
        if (check) { check.style.display = isLast ? 'none' : ''; check.onclick = function(){ checkQuestion(formId); }; }
        const submitBtn = document.getElementById(formId === 'testA' ? 'btnSubmitA' : 'btnSubmitB');
        if (submitBtn) {
          submitBtn.style.display = isLast ? '' : 'none';
          submitBtn.disabled = false;
        }
        // progress bar
        const isA = formId === 'testA';
        const progressFill = isA ? document.getElementById('progressFillA') : document.getElementById('progressFillB');
        const progressText = isA ? document.getElementById('progressTextA') : document.getElementById('progressTextB');
        const pct = total > 0 ? Math.round(((index+1)/total) * 100) : 0;
        if (progressFill) progressFill.style.width = pct + '%';
        if (progressText) progressText.textContent = `${index+1} / ${total}`;
      }

      function prevQuestion(formId) {
        const idx = currentIndex[formId];
        const newIdx = Math.max(0, idx - 1);
        showQuestion(formId, newIdx);
      }

      function nextQuestion(formId) {
        const form = document.getElementById(formId);
        const questions = Array.from(form.querySelectorAll('.question'));
        const idx = currentIndex[formId];
        const newIdx = Math.min(questions.length - 1, idx + 1);
        showQuestion(formId, newIdx);
      }

      function checkQuestion(formId) {
        // Validate the current question and show feedback without changing question
        const form = document.getElementById(formId);
        const idx = currentIndex[formId];
        const questions = Array.from(form.querySelectorAll('.question'));
        const q = questions[idx];
        if (!q) return;
        const ansDiv = q.querySelector('.answer');
        const firstInput = q.querySelector('input');
        const inputName = firstInput ? firstInput.name : null;
        const rawAnswer = formId === 'testB' ? shortAnswerKey[inputName] : answers[inputName];
        const correctAnswer = rawAnswer ? String(rawAnswer).split('|')[0].trim() : null;
        let explanation = '';
        if (rawAnswer) {
          const parts = String(rawAnswer).split('|');
          explanation = parts.length > 1 ? parts.slice(1).join('|').trim() : (formId === 'testB' ? String(rawAnswer).trim() : '');
        }

        if (q.querySelector('input[type="radio"]')) {
          const selected = q.querySelector('input[type="radio"]:checked');
          const userAnswer = selected ? selected.value : '';
          if (userAnswer === correctAnswer) {
            if (ansDiv) {
              ansDiv.textContent = "Correct! Answer: " + correctAnswer + (explanation ? " â€” " + explanation : "");
              ansDiv.className = "answer correct";
              ansDiv.classList.remove('hidden'); ansDiv.style.display = 'block';
            }
          } else {
            if (ansDiv) {
              ansDiv.textContent = "Incorrect. Correct Answer: " + (correctAnswer || "") + (explanation ? " â€” " + explanation : "");
              ansDiv.className = "answer incorrect";
              ansDiv.classList.remove('hidden'); ansDiv.style.display = 'block';
            }
          }
        } else {
          const textInput = q.querySelector('input[type="text"]');
          const userText = textInput ? textInput.value.trim() : '';
          if (userText && userText.toLowerCase() === (correctAnswer || '').toLowerCase()) {
            if (ansDiv) {
              ansDiv.textContent = "Correct!";
              ansDiv.className = "answer correct";
              ansDiv.classList.remove('hidden'); ansDiv.style.display = 'block';
            }
          } else {
            if (ansDiv) {
              ansDiv.textContent = "Suggested Answer: " + (correctAnswer || "") + (explanation ? " â€” " + explanation : "");
              ansDiv.className = "answer incorrect";
              ansDiv.classList.remove('hidden'); ansDiv.style.display = 'block';
            }
          }
        }
      }

      function initPaging() {
        ['testA','testB'].forEach(id => {
          const form = document.getElementById(id);
          if (!form) return;
          let questions = Array.from(form.querySelectorAll('.question'));
          // Dedupe any accidental duplicate question cards (same text)
          const seen = new Set();
          questions.forEach(q => {
            const t = (q.querySelector('p')?.textContent || '').trim();
            if (t && seen.has(t)) { q.remove(); }
            else if (t) { seen.add(t); }
          });
          // Refresh questions list after possible removals
          questions = Array.from(form.querySelectorAll('.question'));
          // 1) Strip leading numbers from question text (e.g., "1. ")
          questions.forEach(q => {
            const p = q.querySelector('p');
            if (p) p.textContent = (p.textContent || '').replace(/^\s*\d+\.?\s*/, '');
          });
          // 2) Randomize and select a subset of 20 questions (out of up to 40)
          const shuffled = questions.map(q => ({ q, sort: Math.random() }))
                                    .sort((a,b) => a.sort - b.sort)
                                    .map(({q}) => q);
          const subset = shuffled.slice(0, 20);
          const actions = form.querySelector('.form-actions');
          // Remove non-selected questions from DOM
          questions.forEach(q => { if (!subset.includes(q)) q.remove(); });
          // Append selected in chosen order
          subset.forEach(q => form.insertBefore(q, actions));
          // hide all initially
          subset.forEach(q => q.style.display = 'none');
          // show first
          showQuestion(id, 0);
          // Keyboard shortcuts: N for Next, C for Check, Enter -> Check
          form.addEventListener('keydown', function(ev){
            const key = ev.key.toLowerCase();
            if (key === 'n') { ev.preventDefault(); nextQuestion(id); }
            if (key === 'c') { ev.preventDefault(); checkQuestion(id); }
            if (key === 'enter'){
              const active = document.activeElement;
              if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')){
                ev.preventDefault();
                // keep Enter mapped to Check for quick validation
                checkQuestion(id);
              }
            }
          });
        });
      }

      // Remove show-answer buttons since we validate/correct before advancing
      document.querySelectorAll('.show-answer-btn').forEach(b => b.remove());

      initPaging();

      // Ensure the translucent backdrop covers the full page height (not just the viewport)
      const backdrop = document.querySelector('.card-backdrop');
      const page = document.querySelector('.page');
      function updateBackdrop(){
        if (!backdrop || !page) return;
        const rect = page.getBoundingClientRect();
        // page offset relative to document
        const pageTop = page.offsetTop;
        backdrop.style.position = 'absolute';
        backdrop.style.left = (rect.left + window.pageXOffset) + 'px';
        backdrop.style.top = pageTop + 'px';
        backdrop.style.width = rect.width + 'px';
        backdrop.style.height = page.offsetHeight + 'px';
        backdrop.style.transform = 'none';
      }
      updateBackdrop();
      window.addEventListener('resize', updateBackdrop);
      // also update after a short delay in case fonts/images change layout
      setTimeout(updateBackdrop, 500);
      // Watch for layout changes (content added/removed) and update backdrop
      const observer = new MutationObserver(updateBackdrop);
      observer.observe(page, { childList: true, subtree: true });
    });
  </script>
  </div>
</body>
</html>

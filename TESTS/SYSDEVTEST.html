<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>System Development Practice Test</title>
  <style>
    /* Extravagant theme: gradients, glass cards, animated accents */
    :root{
      --bg-start:#0f2027;
      --bg-mid:#203a43;
      --bg-end:#2c5364;
      --card:#ffffff22;
      --accent1:#ff6b6b;
      --accent2:#f7b733;
      --accent3:#8e44ad;
      --glass-blur:8px;
    }

    html,body{height:100%;}
    body {
      font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      min-height:100%;
      /* layered gradients: make them cover, not tile, and fixed during scroll */
      background: radial-gradient(1200px 600px at 10% 10%, rgba(255,107,107,0.08), transparent 10%),
                  linear-gradient(135deg, var(--bg-start), var(--bg-mid) 40%, var(--bg-end));
      background-repeat: no-repeat, no-repeat;
      background-attachment: fixed, fixed;
      background-size: cover, cover;
      background-position: center center, center center;
      color: #fbfbff;
      display:flex;
      justify-content:center;
      padding:40px 24px;
      overflow-x: hidden;
    }

    /* Page card */
    .page {
      position: absolute;
      z-index: 2;
      width: min(1100px, 96%);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border-radius: 18px;
      padding: 28px;
      box-shadow: 0 10px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
      backdrop-filter: blur(var(--glass-blur));
      border: 1px solid rgba(255,255,255,0.04);
      overflow: visible;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Ensure page children sit above backdrop */
    .page > * { position: relative; z-index: 2; }

    h1, h2 { color: #fff; text-shadow: 0 2px 12px rgba(0,0,0,0.6); }

    .toggle-bar {
      display:flex;
      gap:12px;
      margin-bottom:22px;
      align-items:center;
    }

    /* Fancy buttons */
    button {
      border: none;
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
      color: #ffffff;
      font-weight: 700;
      letter-spacing: .3px;
      transition: transform .18s ease, box-shadow .18s ease;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
      background: linear-gradient(90deg,var(--accent1),var(--accent2));
    }

    button#btnShowB { background: linear-gradient(90deg,#6a11cb,#2575fc); color:#fff; }
    /* removed btnToggleMode style (button removed) */

    button:hover{ transform: translateY(-3px) scale(1.02); box-shadow: 0 10px 28px rgba(0,0,0,0.45); }
    button:disabled{ opacity:.5; cursor:not-allowed; transform:none; box-shadow:none; }

    /* Questions as glass cards */
    .question {
      margin-bottom: 16px;
      padding: 16px 18px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.03);
      box-shadow: 0 8px 20px rgba(12,20,30,0.45);
      transition: transform .18s ease, box-shadow .18s ease;
    }

    .question:hover{ transform: translateY(-6px); box-shadow: 0 18px 40px rgba(12,20,30,0.55); }

    .question p{ margin:0 0 10px; color:#f6f7fb; font-weight:600; }
    .question p{ overflow-wrap: anywhere; word-break: break-word; }
    .question input.blank { padding: 12px 14px; border-radius: 8px; max-width: 100%; min-height: 44px; }
    .blank-wrap { display:inline-flex; align-items:center; gap:6px; }

    input[type="radio"], input[type="checkbox"]{ accent-color: var(--accent3); transform: scale(1.08); margin-right:6px; }

    .answer {
      margin-top: 10px;
      font-weight: 800;
      color: #ffffff;
      padding: 12px 14px;
      border-radius: 10px;
      display:inline-block;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
      background: linear-gradient(135deg, #4b5bd6 0%, #5b3f95 100%);
      border-left: 4px solid #f093fb;
    }

    .show-answer-btn {
      margin-top: 8px;
      margin-left: auto;
      margin-right: auto;
      padding: 6px 12px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(90deg, #3498db, #2980b9);
      color: #fff;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      transition: transform .18s ease, box-shadow .18s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: block;
      width: 50%;
    }

    .show-answer-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }

    .show-answer-btn:active {
      transform: translateY(0);
    }

    .correct { 
      background: linear-gradient(135deg, #1f9e4d 0%, #1a7f3e 100%);
      color: #ffffff;
      border-left: 4px solid #1abc9c;
    }
    .incorrect { 
      background: linear-gradient(135deg, #d64545 0%, #b83636 100%);
      color: #ffffff;
      border-left: 4px solid #e74c3c;
    }

    .hidden { display:none !important; }

    /* Dark mode tweaks */
    .dark-mode { filter: brightness(.96) saturate(.9); }

    /* Responsive tweaks */
    @media (max-width:700px){
      html, body { height: auto; }
      body { padding: 20px 12px; overflow-x: hidden; }
      .page { 
        position: absolute;
        width: 100%;
        padding: 16px;
        top: auto;
        left: 0;
        transform: none;
      }
      .test-options { grid-template-columns: 1fr; gap: 12px; }
      .card-backdrop {
        position: absolute;
        left: 0;
        width: 100%;
        transform: none;
      }
      .toggle-bar { 
        flex-direction: column;
        gap: 8px;
        margin-bottom: 16px;
      }
      button { 
        width: 100%;
        padding: 12px 10px;
        font-size: 14px;
      }
      .question {
        margin-bottom: 12px;
        padding: 12px 14px;
      }
      .question p {
        font-size: 14px;
        margin: 0 0 8px;
      }
      .answer {
        font-size: 13px;
        padding: 6px 8px;
        margin-top: 8px;
      }
      .form-actions {
        position: sticky;
        bottom: 10px;
        background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.04));
        backdrop-filter: blur(6px);
        border-radius: 12px;
        padding: 10px;
        gap: 8px;
        margin-top: 16px;
      }
      h2 { font-size: 18px; }
      input[type="text"] { font-size: 14px; }
      label { 
        display: block;
        margin-bottom: 6px;
        font-size: 13px;
      }
      .question input.blank { display:block; width:100%; min-width:0 !important; margin:6px 0; }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      * { animation: none !important; transition: none !important; }
    }

    /* Form actions (submit/reset) match top toggle spacing */
    .form-actions {
      display:flex;
      gap:12px; /* same gap as .toggle-bar */
      margin-top:22px;
      align-items:center;
      justify-content:flex-start;
      position: relative;
      z-index: 10;
    }
    .help-shortcuts { margin-left: auto; font-size: 12px; color: #ffffff; opacity: .9; cursor: help; }
    .help-shortcuts .popover { display:none; position:absolute; right:10px; top:110%; background: rgba(0,0,0,0.85); color:#fff; padding:12px 14px; border-radius:8px; box-shadow: 0 6px 18px rgba(0,0,0,0.35); white-space: pre-line; line-height: 1.5; max-width: min(90vw, 480px); min-width: 280px; }
    .help-shortcuts.open .popover { display:block; }
    .help-shortcuts:focus .popover, .help-shortcuts:hover .popover { display:block; }
    .form-actions button {
      position: relative;
      z-index: 11;
    }

    /* Stylish progress bar */
    .progress { display:flex; align-items:center; gap:10px; margin: 8px 0 18px; }
    .progress-track { flex:1; height:10px; border-radius:999px; background: rgba(255,255,255,0.12); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); overflow:hidden; }
    .progress-fill { height:100%; width:0%; background: linear-gradient(90deg,#6a11cb,#2575fc); border-radius:999px; box-shadow: 0 0 12px rgba(37,117,252,0.6); transition: width .3s ease; }
    .progress-text { min-width:60px; font-weight:700; color:#ffffff; text-shadow: 0 1px 6px rgba(0,0,0,0.6); }

    /* Animated accents */
    .accents{ position:fixed; inset:0; pointer-events:none; overflow:visible; z-index:0; }
    .blob{
      position:absolute;
      width:260px; height:260px; border-radius:50%;
      filter: blur(40px) saturate(130%);
      opacity:0.55; mix-blend-mode:screen; transform: translate3d(0,0,0);
      animation: floaty 8s ease-in-out infinite;
    }
    .blob.b1{ left:6%; top:8%; background: radial-gradient(circle at 30% 30%, rgba(255,107,107,0.95), rgba(247,183,51,0.6)); animation-duration:10s; }
    .blob.b2{ right:8%; top:18%; width:320px;height:320px; background: radial-gradient(circle at 20% 20%, rgba(106,17,203,0.9), rgba(37,117,252,0.55)); animation-duration:12s; }
    .blob.b3{ left:20%; bottom:6%; width:200px;height:200px; background: radial-gradient(circle at 30% 30%, rgba(46,204,113,0.9), rgba(39,174,96,0.4)); animation-duration:9s; }

    @keyframes floaty{
      0%{ transform: translateY(0) scale(1) rotate(0deg); }
      50%{ transform: translateY(-18px) scale(1.06) rotate(6deg); }
      100%{ transform: translateY(0) scale(1) rotate(0deg); }
    }

    /* Shimmer for page heading */
    .shimmer {
      position:relative; overflow:hidden; display:inline-block;
    }
    .shimmer::after{
      content:''; position:absolute; top:0; left:-60%; width:40%; height:100%;
      background: linear-gradient(120deg, rgba(255,255,255,0), rgba(255,255,255,0.28), rgba(255,255,255,0));
      transform: skewX(-18deg);
      animation: shimmer 3.6s linear infinite;
      mix-blend-mode: overlay; pointer-events:none;
    }
    @keyframes shimmer{ 0%{ left:-60%; } 100%{ left:120%; } }

    /* Full-height translucent backdrop behind the page card (positioned by JS) */
    .card-backdrop{
      border-radius:18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      box-shadow: 0 10px 30px rgba(2,6,23,0.45);
      z-index:1; 
      pointer-events:none;
      backdrop-filter: blur(var(--glass-blur));
      border: 1px solid rgba(255,255,255,0.03);
    }

    /* Results Page Styling */
    .results-summary {
      text-align: center;
      margin: 24px 0;
      padding: 24px;
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    .score-display {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
    }
    .score-number {
      font-size: 48px;
      font-weight: 800;
      color: #fff;
      text-shadow: 0 2px 12px rgba(0,0,0,0.6);
    }
    .score-percentage {
      font-size: 36px;
      font-weight: 700;
      color: #ffffff;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
    }
    .results-message {
      font-size: 24px;
      font-weight: 600;
      margin-top: 12px;
    }
    .results-details {
      margin: 20px 0;
    }
    .results-details h3 {
      color: #fff;
      margin-bottom: 16px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.5);
    }
    .result-item {
      margin-bottom: 16px;
      padding: 14px 16px;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .result-item.correct {
      border-left: 4px solid #2ecc71;
    }
    .result-item.incorrect {
      border-left: 4px solid #e74c3c;
    }
    .result-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .result-icon {
      font-size: 20px;
      font-weight: 800;
    }
    .result-item.correct .result-icon {
      color: #2ecc71;
    }
    .result-item.incorrect .result-icon {
      color: #e74c3c;
    }
    .result-num {
      font-weight: 700;
      color: #ddd;
    }
    .result-question {
      color: #f6f7fb;
      margin-bottom: 8px;
      font-weight: 600;
    }
    .result-answer, .result-correct {
      color: #ddd;
      margin: 4px 0;
      font-size: 14px;
    }
    .result-answer strong, .result-correct strong {
      color: #fff;
    }
    .result-explanation {
      margin-top: 8px;
      padding: 8px 12px;
      background: rgba(106,17,203,0.15);
      border-radius: 8px;
      color: #d4d4ff;
      font-size: 13px;
      font-style: italic;
    }

    /* Intro page styles */
    *, *::before, *::after { box-sizing: border-box; }
    .intro-page { margin-bottom: 24px; }
    .test-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
    }
    .test-option-card {
      padding: 18px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: 0 8px 20px rgba(12,20,30,0.45);
      transition: transform .18s ease, box-shadow .18s ease;
      min-width: 0;
    }
    .test-option-card:hover { transform: translateY(-4px); box-shadow: 0 16px 32px rgba(12,20,30,0.55); }
    .test-type { color:#eaeaff; opacity: .9; margin-top: 4px; }
    .test-features { list-style: none; padding: 0; margin: 10px 0 16px; color:#ddd; }
    .test-features li { margin: 6px 0; }
    .start-test-btn { width: 100%; }

    /* Results actions (top area with Try Again) */
    .results-actions { display: flex; justify-content: flex-end; gap: 10px; margin: 8px 0 12px; }

    /* Shortcut toast (accessible, brief, respects reduced motion) */
    .shortcut-toast {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 10px 14px;
      border-radius: 10px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.45);
      font-weight: 700;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity .25s ease;
    }
    .shortcut-toast.show { opacity: 1; }
    @media (prefers-reduced-motion: reduce){
      .shortcut-toast { transition: none; }
    }
  </style>
</head>
<body>
  <div class="accents" aria-hidden="true">
    <span class="blob b1"></span>
    <span class="blob b2"></span>
    <span class="blob b3"></span>
  </div>
  <div class="card-backdrop" aria-hidden="true"></div>
  <div class="page">
  <!-- Intro Page -->
  <div id="introPage" class="intro-page">
    <h1 class="shimmer">System Development Practice Tests</h1>
    <p style="text-align: center; margin-bottom: 24px; font-size: 18px; color: #ddd;">Ideally to be ready for the real test you should be able to fill out the medium tests with ease and most of the hard test answers</p>
    <p style="text-align: center; margin-bottom: 24px; font-size: 18px; color: #ddd;">Choose your test format</p>
    <div class="test-options">
      <div class="test-option-card" id="optionA">
        <h2>Easy Test</h2>
        <p class="test-type">Multiple Choice & True/False</p>
        <ul class="test-features">
          <li>âœ“ 10 randomized questions</li>
          <li>âœ“ Multiple choice options</li>
          <li>âœ“ True/False questions</li>
          <li>âœ“ Instant feedback on each answer</li>
          <li>âœ“ Detailed explanations provided</li>
        </ul>
        <button class="start-test-btn" data-test="A" id="startTestA">Start Easy Test</button>
      </div>
      <div class="test-option-card" id="optionC">
        <h2>Medium Test</h2>
        <p class="test-type">Fill in the Blanks</p>
        <ul class="test-features">
          <li>âœ“ 10 randomized questions</li>
          <li>âœ“ Fill in missing words</li>
          <li>âœ“ Case-insensitive matching</li>
          <li>âœ“ Suggested answers provided</li>
          <li>âœ“ Detailed explanations optional</li>
        </ul>
        <button class="start-test-btn" data-test="C" id="startTestC">Start Medium Test</button>
      </div>
      <div class="test-option-card" id="optionB">
        <h2>Hard Test</h2>
        <p class="test-type">Short Answer</p>
        <ul class="test-features">
          <li>âœ“ 10 randomized questions</li>
          <li>âœ“ Open-ended responses</li>
          <li>âœ“ Test your recall ability</li>
          <li>âœ“ Suggested answers provided</li>
          <li>âœ“ Comprehensive feedback</li>
        </ul>
        <button class="start-test-btn" data-test="B" id="startTestB">Start Hard Test</button>
      </div>
    </div>
  </div>
  

  <!-- Optional: Plain-text question sources (easy to replace). One question per line. -->
  <script type="text/plain" id="sourceA">
Q1: Functional requirements define how a system should perform. | True | False
A1: False | Functional = what the system must do; the how is non-functional.

Q2: Non-functional requirements focus on how a system should perform. | True | False
A2: True | Non-functional defines how the system performs (quality attributes).

Q3: Functional requirements are not static and can be adjusted via structured processes. | True | False
A3: True | Functional requirements can be adjusted through change control or backlog refinement.

Q4: Change control is used in Agile to adjust the scope of functional requirements. | True | False
A4: False | Change Control is used in Waterfall; Agile uses Backlog Refinement.

Q5: Backlog refinement is used in Agile to adjust functional requirements. | True | False
A5: True | In Agile, backlog refinement adjusts the scope of functional requirements.

Q6: Performance, reliability, and security are examples of non-functional requirement aspects. | True | False
A6: True | These are all non-functional requirement aspects.

Q7: Portability and maintainability belong to Operational non-functional requirements. | True | False
A7: True | Portability, Maintainability, System Integration and Technical Environment are part of Operational non-functional requirements.

Q8: Availability and reliability are part of Performance non-functional requirements. | True | False
A8: False | Availability and Reliability, Speed and Capacity are part of Operational requirements.

Q9: Access control and encryption are examples of Security non-functional requirements. | True | False
A9: True | Access Control, Encryption, Virus Control and System Value are Security non-functional requirements.

Q10: Laws and government regulations are part of Cultural & Political requirements. | True | False
A10: True | Laws & government regulations, Centralized vs Local Control, Language Differences and Scrutiny of Local Laws in a Globalized Organizationare are Cultural & Political requirements.

Q11: Problem Analysis focuses on understanding â€˜whyâ€™ before â€˜whatâ€™. | True | False
A11: True | Problem Analysis identifies the business problem, focusing on 'why' first.

Q12: Root Cause Analysis focuses on symptoms rather than underlying issues. | True | False
A12: False | Root Cause Analysis digs into underlying causes, not just symptoms.

Q13: Duration Analysis looks at time taken for process activities to find efficiency opportunities. | True | False
A13: True | Duration Analysis examines time taken to identify efficiency opportunities.

Q14: Activity-Based Costing includes only direct costs. | True | False
A14: False | Activity-Based Costing includes both direct and indirect costs.

Q15: Informal Benchmarking involves analyzing the current technology environment and trends, to inform decisions about technology investments. | True | False
A15: False | Informal Benchmarking compares processes with other businesses for improvement ideas.

Q16: Outcome Analysis identifying activities that do not add value and can be eliminated. | True | False
A16: False | Outcome Analysis uses past results to guide future actions.

Q17: Technology Analysis examines current environment and trends to inform investments. | True | False
A17: True | Technology Analysis looks at current tech environment and trends for investment decisions.

Q18: Activity Elimination targets nonâ€“value-adding activities to free resources. | True | False
A18: True | Activity Elimination removes nonâ€“value-adding activities to free up resources.

Q19: Open communication helps prevent success. | True | False
A19: False | Open communication is key to preventing team conflict.

Q20: Effort estimation is not important for cost control. | True | False
A20: False | Effort estimation is crucial for cost control.

Q21: Which process adjusts functional requirements in Waterfall? | Change Control | Backlog Refinement | Scope Creep | Kanban
A21: Change Control | Change Control is the formal process in Waterfall for adjusting requirements.

Q22: Which non-functional category includes Availability? | Operational | Performance | Security | Cultural & Political
A22: Operational | Availability is part of Operational non-functional requirements.

Q23: Which analysis strategy identifies inefficient code as the cause of performance issues? | Problem Analysis | Root Cause Analysis | Duration Analysis | Outcome Analysis
A23: Root Cause Analysis | Root Cause Analysis digs deep to find the underlying cause of issues.

Q24: Which requirements gathering technique builds relationships with stakeholders? | Interviewing | Observation | Questionnaire | Document Analysis
A24: Interviewing | Interviewing builds relationships and gathers detailed information.

Q25: Who defines requirements? | Project Managers and Developers | Testers and Customers | Business Analysts and Stakeholders | System Architects and End Users
A25: Business Analysts and Stakeholders | Business Analysts work with Stakeholders to define requirements.

Q26: What does WBS stand for? | Work Breakdown Structure | Workflow Business System | Work Balance Sheet | Work Budget Strategy
A26: Work Breakdown Structure | WBS breaks down a project into smaller, manageable tasks.

Q27: Which are the three trade-offs of effort estimation? | Speed, Reliability, Security | Skills, Morale, Rewards | Scope, Time, Cost | Availability, Portability, Maintainability
A27: Scope, Time, Cost | The project triangle balances Scope, Time, and Cost.

Q28: What is scope creep? | Breaking down project tasks | Adding new requirements after project starts | Visualizing workflow | Estimating costs
A28: Adding new requirements after project starts | Scope creep is uncontrolled expansion of project requirements.

Q29: Which method visualizes work process and flow? | WBS | Benchmarking | Shadowing | Kanban 
A29: Kanban | Kanban boards visualize workflow and help manage tasks.

Q30: High morale indicates what? | Scope creep | Team has jelled | Poor communication | Cost control
A30: Team has jelled | High morale means the team has bonded and works well together.

Q31: Which requirements gathering technique provides a comprehensive understanding of system functionalities and business processes? | Interviewing | Observation | Questionnaire | Document Analysis
A31: Document Analysis | Document Analysis provides comprehensive system and process understanding.

Q32: Which requirements analysis strategy involves looking at past results to guide future actions? | Outcome Analysis | Technology Analysis | Activity Elimination | Informal Benchmarking
A32: Outcome Analysis | Outcome Analysis examines past results to inform future decisions.

Q33: Which non-functional category includes Portability? | Performance | Security | Cultural & Political | Operational
A33: Operational | Portability, Maintainability, System integration, and Technical Envrionment are all part of Operational non-functional requirements.

Q34: Which strategy involves analyzing the current technology environment and trends? | Problem Analysis | Technology Analysis | Duration Analysis | Activity-Based Costing
A34: Technology Analysis | Technology Analysis examines current tech environment and trends.

Q35: Which requirements gathering technique can scale to a large number of respondents? | Interviewing | Observation | Questionnaire | Shadowing
A35: Questionnaire | Questionnaires can efficiently gather input from many respondents.

Q36: Which strategy involves identifying all costs associated with a business activity? | Activity-Based Costing | Root Cause Analysis | Outcome Analysis | Duration Analysis
A36: Activity-Based Costing | Activity-Based Costing identifies all direct and indirect costs.

Q37: Which non-functional category includes Virus Control? | Operational | Performance | Security | Cultural & Political
A37: Security | Virus Control is part of Security non-functional requirements.

Q38: Which strategy involves comparing processes with other businesses? | Technology Analysis | Activity Elimination | Informal Benchmarking | Problem Analysis
A38: Informal Benchmarking | Informal Benchmarking compares processes with other organizations.

Q39: Which requirements gathering technique ensures design is centered around user needs? | Interviewing | Observation | Questionnaire | Document Analysis
A39: Observation | Observation ensures design is based on actual user behavior and needs.

Q40: Which factor is important when forming a project team? | High morale | Member availability and skills | Office Location Preference | How Much Beer your each member drank on the weekend
A40: Member availability and skills | Team formation requires matching member availability and skills to project needs.
  </script>

  <script type="text/plain" id="sourceC">
Q1: Fill in the blanks: The two main development approaches are ___ and ___.
A1: Agile | Waterfall | Agile focuses on iteration; Waterfall is sequential.

Q2: A projectâ€™s primary trade-offs are ___, ___, and ___.
A2: Scope | Time | Cost | These form the classic project management triangle.

Q3: Functional requirements define ___, while non-functional requirements focus on ___.
A3: What a system must do | How it should perform | Function vs performance.

Q4: In Waterfall, changes to functional requirements are handled through ___ control.
A4: Change | Structured change control ensures scope stability.

Q5: In Agile, adjustments to functional requirements occur through ___ refinement.
A5: Backlog | Backlog refinement balances value and feasibility.

Q6: Non-functional requirements include aspects such as ___, ___, ___, and ___.
A6: Performance | Usability | Reliability | Security | These define system quality.

Q7: Operational non-functional requirements include ___, ___, ___, and ___.
A7: Technical Environment | System Integration | Portability | Maintainability | These ensure smooth operation.

Q8: Performance non-functional requirements include ___, ___, ___, and ___.
A8: Speed | Capacity | Availability | Reliability | These measure efficiency.

Q9: Security non-functional requirements include ___, ___, ___, and ___.
A9: System Value | Access Control | Encryption & Authentication | Virus Control | These protect data.

Q10: Cultural & Political non-functional requirements include ___, ___, ___, and ___.
A10: Centralized vs Local Control | Language Differences | Laws & Government Regulations | Scrutiny of Local Laws | These reflect organizational context.

Q11: Problem Analysis focuses on understanding ___ before defining ___.
A11: Why | What | It clarifies the business problem.

Q12: Root Cause Analysis identifies ___ rather than just addressing ___.
A12: Underlying cause | Symptoms | Ensures lasting solutions.

Q13: Duration Analysis examines ___ taken for activities to identify ___.
A13: Time | Efficiency opportunities | Streamlines processes.

Q14: Activity-Based Costing considers both ___ and ___ costs.
A14: Direct | Indirect | Provides accurate cost picture.

Q15: Informal Benchmarking compares ___ with other businesses to identify ___.
A15: Processes | Improvements | Gains insights from peers.

Q16: Outcome Analysis looks at ___ of past actions to guide ___.
A16: Results | Future decisions | Learns from history.

Q17: Technology Analysis studies ___ and ___ to inform investments.
A17: Current environment | Trends | Guides tech choices.

Q18: Activity Elimination removes ___ activities that do not ___.
A18: Non-value | Add value | Frees resources.

Q19: Interviewing as a requirements technique provides ___ understanding through ___.
A19: In-depth | Direct communication | Builds clarity.

Q20: Observation helps identify ___ requirements by watching ___.
A20: Implicit | Real-world behavior | Ensures user-centered design.

Q21: Questionnaires are useful for ___ projects because they provide ___.
A21: Large | Scalable data | Standardized responses.

Q22: Document Analysis reduces ___ by basing requirements on ___.
A22: Miscommunication | Existing documents | Ensures accuracy.

Q23: Shadowing involves ___ to understand ___.
A23: Following users | Their tasks | Captures real workflows.

Q24: Requirements are defined by ___ and ___.
A24: Business Analysts | Stakeholders | They capture needs.

Q25: Project work is executed by ___ and ___.
A25: Project Manager | Developers | They deliver solutions.

Q26: A Work Breakdown Structure decomposes a project into ___ components.
A26: Smaller | Manageable | Provides detailed scope.

Q27: Scope creep refers to adding ___ after a project is ___.
A27: New requirements | Underway | Expands scope unexpectedly.

Q28: Open communication helps prevent ___.
A28: Team conflict | Encourages collaboration.

Q29: Skill sets are important when ___ a project team.
A29: Staffing | Ensures capability alignment.

Q30: High morale indicates a team has ___.
A30: Jelled | Working well together.

Q31: Possible team motivation strategies include ___ and ___.
A31: Rewards | Recognition | Boosts performance.

Q32: Kanban is used for ___ work process and ___.
A32: Visualizing | Flow | Tracks tasks.

Q33: Effort estimation is critical for managing ___.
A33: Cost control | Prevents overruns.

Q34: Important considerations for forming a group project include ___ and ___.
A34: Member availability | Skills | Ensures effective collaboration.

Q35: Fill in the blanks: Functional requirements are adjusted to balance ___, ___, and ___.
A35: Business value | Technical feasibility | Project constraints | Ensures maximum value delivery.

Q36: Non-functional requirements related to usability focus on ___ interaction.
A36: User | Ensures ease of use.

Q37: Reliability as a non-functional requirement ensures system ___ over time.
A37: Consistency | Maintains trust.

Q38: Maintainability ensures a system can be ___ and ___ efficiently.
A38: Updated | Fixed | Supports long-term use.

Q39: Availability measures how often a system is ___.
A39: Accessible | Ensures uptime.

Q40: Encryption & Authentication protect system ___ and ___.
A40: Data | Access | Safeguards information.
  </script>

  <script type="text/plain" id="sourceB">
Q1: Define functional requirements and explain their purpose.
A1: Functional requirements define what a system must do, describing its core features and tasks.

Q2: Define non-functional requirements and explain their focus.
A2: Non-functional requirements focus on how the system performs, covering quality attributes like speed, security, and usability.

Q3: How are functional requirements adjusted in scope during a project?
A3: They are adjusted through structured processes such as change control (Waterfall) or backlog refinement (Agile).

Q4: Name two structured processes used to adjust functional requirements.
A4: Change control in Waterfall and backlog refinement in Agile.

Q5: List four aspects covered by non-functional requirements.
A5: Performance, usability, reliability, security, maintainability.

Q6: Which non-functional category includes Portability and Maintainability?
A6: Operational â€” includes portability, maintainability, technical environment, and system integration.

Q7: Which non-functional category includes Speed and Capacity?
A7: Performance â€” includes speed, capacity, availability, reliability.

Q8: Which non-functional category includes Access Control and Encryption?
A8: Security â€” includes system value, access control, encryption & authentication, virus control.

Q9: Which non-functional category includes Laws and Government Regulations?
A9: Cultural & Political â€” includes laws, government regulations, language differences, centralized vs local control.

Q10: What is the goal of Problem Analysis in requirements analysis?
A10: Problem Analysis identifies and articulates the business problem, focusing on 'why' before 'what'.

Q11: What is the goal of Root Cause Analysis?
A11: Root Cause Analysis identifies underlying causes of problems rather than just symptoms.

Q12: What does Duration Analysis examine?
A12: Duration Analysis examines the time taken for activities to find efficiency opportunities.

Q13: What does Activity-Based Costing include beyond direct costs?
A13: Activity-Based Costing includes indirect costs like rent, utilities, salaries, and marketing in addition to direct costs.

Q14: What is Informal Benchmarking used for?
A14: Informal Benchmarking compares processes with other businesses to identify areas for improvement.

Q15: What is Outcome Analysis used for?
A15: Outcome Analysis uses past results to guide future actions.

Q16: What is Technology Analysis used for?
A16: Technology Analysis examines current technology environment and trends to inform investment decisions.

Q17: What is Activity Elimination used for?
A17: Activity Elimination removes nonâ€“value-adding activities to free resources.

Q18: What is the main benefit of Interviewing as a requirements gathering technique?
A18: Interviewing provides in-depth understanding and builds relationships with stakeholders.

Q19: What is the main benefit of Observation as a requirements gathering technique?
A19: Observation provides real-world understanding of user behavior and reduces miscommunication.

Q20: What is the main benefit of Questionnaires as a requirements gathering technique?
A20: Questionnaires scale to large groups, provide quantitative data, and allow anonymity.

Q21: What is the main benefit of Document Analysis as a requirements gathering technique?
A21: Document Analysis provides comprehensive understanding of systems and identifies gaps efficiently.

Q22: What is Shadowing used for in requirements gathering?
A22: Shadowing involves following users to observe their work and uncover implicit requirements.

Q23: Who defines requirements in a project?
A23: Business analysts and stakeholders define requirements.

Q24: Who does the work after requirements are defined?
A24: Project managers and developers do the work after requirements are defined.

Q25: What does WBS stand for and what is its purpose?
A25: Work Breakdown Structure â€” decomposes a project into smaller components for clarity and scope management.

Q26: What are the three trade-offs of effort estimation?
A26: Scope, Time, Cost â€” the three trade-offs of effort estimation.

Q27: What is scope creep?
A27: Scope creep is adding new requirements after a project has started.

Q28: Why is open communication important in project teams?
A28: Open communication prevents team conflict and supports collaboration.

Q29: Why are skill sets important when staffing a project team?
A29: Skill sets ensure the team has the right expertise for tasks.

Q30: What does high morale indicate in a project team?
A30: High morale indicates the team has 'jelled' and is working well together.

Q31: What is a possible team motivation strategy?
A31: Rewards and recognition motivate teams and improve performance.

Q32: What does Kanban do?
A32: Kanban visualizes work processes and flow.

Q33: Why is effort estimation critical for cost control?
A33: Effort estimation is critical for cost control because it predicts resource needs and expenses.

Q34: What is an important consideration when forming a group project?
A34: Member availability and skills are important considerations when forming a group project.

Q35: Why is rewards and recognition important for team motivation?
A35: Rewards and recognition encourage motivation, engagement, and sustained performance.

Q36: What does Kanban help visualize in project management?
A36: Kanban helps visualize workflow, bottlenecks, and task progress.

Q37: Why is effort estimation critical for managing project costs?
A37: Effort estimation ensures accurate budgeting and prevents overspending.

Q38: What are two important considerations when forming a group project team?
A38: Member availability and skills â€” ensures tasks are covered and team balance is maintained.

Q39: Give an example of how Outcome Analysis might influence future software releases.
A39: Outcome Analysis might lead to more thorough testing if past releases caused support issues.

Q40: Explain how Activity Elimination can improve efficiency in a business process.
A40: Activity Elimination improves efficiency by removing tasks that add no value, freeing resources for useful work.
  </script>

 <!-- Test A -->
  <form id="testA" class="test hidden">
    <h2>Easy Test</h2>
    <div class="progress" id="progressA" aria-live="polite">
      <div class="progress-track"><div class="progress-fill" id="progressFillA"></div></div>
      <div class="progress-text" id="progressTextA">1 / 10</div>
    </div>
    <!-- Questions are generated from #sourceA; static markup removed -->

    <div class="form-actions">
      <button type="button" id="btnPrevA" class="nav-btn">Prev</button>
      <button type="button" id="btnCheckA" class="nav-btn">Show Answer</button>
      <button type="button" id="btnNextA" class="nav-btn">Next</button>
      <button type="button" id="btnSubmitA">Submit Easy Test</button>
      <button type="button" class="help-shortcuts" id="helpA" aria-haspopup="true" aria-expanded="false" aria-label="Keyboard shortcuts help">?
        <span class="popover" role="tooltip">Keyboard Shortcuts:<br>Next = Right Arrow<br>Prev = Left Arrow<br>Show Answer = Up Arrow<br>Hide Answer = Down Arrow</span>
      </button>
    </div>
  </form>

<!-- Test B -->
  <form id="testB" class="test hidden">
    <h2>Hard Test</h2>
    <div class="progress" id="progressB" aria-live="polite">
      <div class="progress-track"><div class="progress-fill" id="progressFillB"></div></div>
      <div class="progress-text" id="progressTextB">1 / 10</div>
    </div>
    <!-- Questions are generated from #sourceB; static markup removed -->

    <div class="form-actions">
      <button type="button" id="btnPrevB" class="nav-btn">Prev</button>
      <button type="button" id="btnCheckB" class="nav-btn">Show Answer</button>
      <button type="button" id="btnResetB" class="nav-btn">Clear Question</button>
      <button type="button" id="btnNextB" class="nav-btn">Next</button>
      <button type="button" id="btnSubmitB">Submit Hard Test</button>
      <button type="button" class="help-shortcuts" id="helpB" aria-haspopup="true" aria-expanded="false" aria-label="Keyboard shortcuts help">?
        <span class="popover" role="tooltip">Keyboard Shortcuts:<br>Next = Right Arrow<br>Prev = Left Arrow<br>Show Answer = Up Arrow<br>Hide Answer = Down Arrow</span>
      </button>
    </div>
  </form>

<!-- Test C -->
  <form id="testC" class="test hidden">
    <h2>Medium Test</h2>
    <div class="progress" id="progressC" aria-live="polite">
      <div class="progress-track"><div class="progress-fill" id="progressFillC"></div></div>
      <div class="progress-text" id="progressTextC">1 / 10</div>
    </div>
    <!-- Questions are generated from #sourceC -->

    <div class="form-actions">
      <button type="button" id="btnPrevC" class="nav-btn">Prev</button>
      <button type="button" id="btnCheckC" class="nav-btn">Show Answer</button>
      <button type="button" id="btnResetC" class="nav-btn">Clear Question</button>
      <button type="button" id="btnNextC" class="nav-btn">Next</button>
      <button type="button" id="btnSubmitC">Submit Medium Test</button>
      <button type="button" class="help-shortcuts" id="helpC" aria-haspopup="true" aria-expanded="false" aria-label="Keyboard shortcuts help">?
        <span class="popover" role="tooltip">Keyboard Shortcuts:<br>Next = Right Arrow<br>Prev = Left Arrow<br>Show Answer = Up Arrow<br>Hide Answer = Down Arrow</span>
      </button>
    </div>
  </form>

  <!-- Results Page -->
  <div id="resultsPage" class="test hidden">
    <h2 id="resultsTitle" tabindex="-1">Test Results</h2>
    <div class="results-actions">
      <button type="button" id="btnTryAgain">Try Again</button>
    </div>
    <div class="results-summary" aria-live="polite">
      <div class="score-display">
        <div class="score-number" id="scoreNumber">0/10</div>
        <div class="score-percentage" id="scorePercentage">0%</div>
      </div>
      <div class="results-message" id="resultsMessage"></div>
    </div>
    <div class="results-details" id="resultsDetails"></div>
  </div>
  <!-- Shortcut toast for keyboard feedback -->
  <div id="shortcutToast" class="shortcut-toast" role="status" aria-live="polite" aria-atomic="true"></div>
  <script>
// Answers object - populated dynamically by renderFromPlainText from sourceA
const answers = {};
// Short answer key - populated dynamically by renderFromPlainText from sourceB
const shortAnswerKey = {};
// Blanks answer key for Medium Test
const blanksAnswerKey = {};

// Lenient normalization for comparing answers (case/spacing/punctuation)
function normalizeAnswer(text) {
  if (text == null) return '';
  return String(text)
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '') // strip diacritics
    .replace(/&/g, ' and ') // treat & as 'and'
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, ' ') // collapse punctuation to spaces
    .replace(/\s+/g, ' ') // collapse multiple spaces
    .trim();
}

// Conservative synonyms for blanks to accept common variations
const RAW_SYNONYMS = {
  Authentication: ['auth', 'authenticate', 'authentication'],
  Encryption: ['encrypt', 'encrypted', 'encryption', 'crypto'],
  Availability: ['uptime', 'available', 'availability'],
  Maintainability: ['maintainable', 'maintenance', 'maintainability'],
  Portability: ['portable', 'portability'],
  Performance: ['speed', 'throughput', 'performance'],
  Reliability: ['reliable', 'reliability'],
  Usability: ['user friendly', 'usable', 'usability'],
  Security: ['secure', 'security'],
  Data: ['data', 'information', 'info'],
  Consistency: ['consistent', 'consistency'],
  Results: ['outcomes', 'results'],
  Backlog: ['backlog', 'product backlog'],
  Change: ['change', 'change control', 'change management'],
  Cost: ['cost', 'budget'],
  Time: ['time', 'schedule'],
  Scope: ['scope', 'requirements scope'],
};
const SYN_MAP = (() => {
  const m = {};
  for (const [k, arr] of Object.entries(RAW_SYNONYMS)){
    const nk = normalizeAnswer(k);
    m[nk] = new Set(arr.map(normalizeAnswer).concat(nk));
  }
  return m;
})();
function isEquivalentAnswer(user, expected){
  const u = normalizeAnswer(user);
  const e = normalizeAnswer(expected);
  if (u === e) return true;
  const set = SYN_MAP[e];
  return set ? set.has(u) : false;
}

    function toggleTest(test) {
      // Hide all forms including results page
      document.getElementById('testA').classList.add('hidden');
      document.getElementById('testB').classList.add('hidden');
      document.getElementById('testC').classList.add('hidden');
      document.getElementById('resultsPage').classList.add('hidden');
      // Hide intro page once a test is selected
      const intro = document.getElementById('introPage');
      if (intro) intro.style.display = 'none';
      // No toggle bar or start buttons present
      
      // Reset the selected test
      const formId = 'test' + test;
      // Re-randomize questions each time a test is started
      if (window.rerandomizeTest) {
        window.rerandomizeTest(test);
      }
      resetForm(test);
      
      // Show the selected test and reset to first question
      document.getElementById(formId).classList.remove('hidden');
      if (window.currentIndex && window.showQuestion) {
        window.currentIndex[formId] = 0;
        window.showQuestion(formId, 0);
      }
      // Update backdrop to new layout
      if (window.requestBackdropUpdate) { window.requestBackdropUpdate(); }
    }

    function submitTest(test) {
      const form = document.getElementById('test' + test);
      if (!form) return;
      const questions = form.querySelectorAll('.question');
      let correctCount = 0;
      let totalCount = questions.length;
      const details = [];

      questions.forEach((q, idx) => {
        const firstInput = q.querySelector('input');
        const inputName = firstInput ? firstInput.name : null;
        const questionText = q.querySelector('p')?.textContent || `Question ${idx+1}`;
        let correctAnswer = null;
        let explanation = '';
        if (test === 'C') {
          // Derive qId from first input (e.g., q1-b1 -> q1)
          const baseName = inputName ? String(inputName).split('-')[0] : null;
          const key = baseName;
          const entry = key ? blanksAnswerKey[key] : null;
          if (entry) {
            correctAnswer = Array.isArray(entry.answers) ? entry.answers.join(', ') : '';
            explanation = entry.explanation || '';
          }
        } else {
          const rawAnswer = inputName ? (test === 'B' ? shortAnswerKey[inputName] : answers[inputName]) : null;
          correctAnswer = rawAnswer ? String(rawAnswer).split('|')[0].trim() : null;
          if (rawAnswer) {
            const parts = String(rawAnswer).split('|');
            explanation = parts.length > 1 ? parts.slice(1).join('|').trim() : (test === 'B' ? String(rawAnswer).trim() : '');
          }
        }
        let userAnswer = "";
        let isCorrect = false;

        if (q.querySelector('input[type="radio"]')) {
          const selected = q.querySelector('input[type="radio"]:checked');
          if (selected) userAnswer = selected.value;
          isCorrect = userAnswer === correctAnswer;
        } else if (test !== 'C') {
          const textInput = q.querySelector('input[type="text"]');
          userAnswer = textInput ? textInput.value.trim() : "";
          isCorrect = userAnswer.toLowerCase() === (correctAnswer || '').toLowerCase();
        } else {
          // blanks: compare each blank with expected
          const blanks = Array.from(q.querySelectorAll('input[type="text"].blank'));
          const baseName = inputName ? String(inputName).split('-')[0] : null;
          const entry = baseName ? blanksAnswerKey[baseName] : null;
          const expected = entry && Array.isArray(entry.answers) ? entry.answers : [];
          const answersGiven = blanks.map(inp => (inp.value || '').trim());
          userAnswer = answersGiven.join(', ');
          isCorrect = expected.length === answersGiven.length && answersGiven.every((ans, i) => isEquivalentAnswer(ans, expected[i] || ''));
        }

        if (isCorrect) correctCount++;
        details.push({
          num: idx + 1,
          question: questionText,
          userAnswer: userAnswer || '(no answer)',
          correctAnswer: correctAnswer,
          explanation: explanation,
          isCorrect: isCorrect
        });
      });

      showResults(test, correctCount, totalCount, details);
    }

    function resetForm(test) {
      const form = document.getElementById('test' + test);
      if (!form) return;
      form.reset();
      // hide and clear answer boxes
      const answersEls = form.querySelectorAll('.answer');
      answersEls.forEach(a => {
        a.classList.add('hidden');
        a.textContent = '';
        a.style.display = 'none';
      });
    }

    let lastTest = 'A';
    function showResults(test, correctCount, totalCount, details) {
      lastTest = test;
      // Hide tests, show results
      document.getElementById('testA').classList.add('hidden');
      document.getElementById('testB').classList.add('hidden');
      document.getElementById('testC').classList.add('hidden');
      document.getElementById('resultsPage').classList.remove('hidden');
      
      // No toggle bar; only Try Again at top
      // Update backdrop for results layout
      if (window.requestBackdropUpdate) { window.requestBackdropUpdate(); }

      // Update title with friendly test name
      const testName = (test === 'A') ? 'Easy Test' : (test === 'B' ? 'Hard Test' : 'Medium Test');
      document.getElementById('resultsTitle').textContent = `${testName} Results`;

      // Calculate percentage
      const percentage = Math.round((correctCount / totalCount) * 100);

      // Update score display
      document.getElementById('scoreNumber').textContent = `${correctCount}/${totalCount}`;
      document.getElementById('scorePercentage').textContent = `${percentage}%`;

      // Set message based on score
      const messageEl = document.getElementById('resultsMessage');
      if (percentage >= 90) {
        messageEl.textContent = 'Excellent work! ðŸŽ‰';
        messageEl.style.color = '#2ecc71';
      } else if (percentage >= 80) {
        messageEl.textContent = 'Great job! ðŸ‘';
        messageEl.style.color = '#27ae60';
      } else if (percentage >= 70) {
        messageEl.textContent = 'Good effort! ðŸ’ª';
        messageEl.style.color = '#f39c12';
      } else if (percentage >= 60) {
        messageEl.textContent = 'Keep practicing! ðŸ“š';
        messageEl.style.color = '#e67e22';
      } else {
        messageEl.textContent = 'Review and try again! ðŸ“–';
        messageEl.style.color = '#e74c3c';
      }

      // Build detailed results
      const detailsEl = document.getElementById('resultsDetails');
      let detailsHtml = '<h3>Question Review</h3>';
      details.forEach(d => {
        const icon = d.isCorrect ? 'âœ“' : 'âœ—';
        const statusClass = d.isCorrect ? 'correct' : 'incorrect';
        detailsHtml += `
          <div class="result-item ${statusClass}">
            <div class="result-header">
              <span class="result-icon">${icon}</span>
              <span class="result-num">Question ${d.num}</span>
            </div>
            <div class="result-question">${d.question}</div>
            <div class="result-answer">Your answer: <strong>${d.userAnswer}</strong></div>
            ${!d.isCorrect ? `<div class="result-correct">Correct answer: <strong>${d.correctAnswer}</strong></div>` : ''}
            ${d.explanation ? `<div class="result-explanation">${d.explanation}</div>` : ''}
          </div>
        `;
      });
      detailsEl.innerHTML = detailsHtml;
    }

    // Attach event listeners to buttons (replace inline onclicks)
    document.addEventListener('DOMContentLoaded', function() {
      // Factory functions to build question HTML
      function createTFQuestion(qId, text){
        const qNum = qId.replace(/^q/, '');
        const idTrue = `${qId}-t`;
        const idFalse = `${qId}-f`;
        return `\n<div class="question" role="group" aria-labelledby="lbl-${qId}">\n  <p id="lbl-${qId}"><span class="qnum">Q${qNum}.</span> ${text}</p>\n  <label for="${idTrue}"><input id="${idTrue}" type="radio" name="${qId}" value="True"> True</label>\n  <label for="${idFalse}"><input id="${idFalse}" type="radio" name="${qId}" value="False"> False</label>\n  <div class="answer hidden" id="ans-${qId}" aria-live="polite"></div>\n</div>`;
      }
      function createMCQuestion(qId, text, options){
        const qNum = qId.replace(/^q/, '');
        const optionsHtml = options.map((val, i) => {
          const oid = `${qId}-o${i+1}`;
          return `  <label for="${oid}"><input id="${oid}" type="radio" name="${qId}" value="${val}"> ${val}</label>`;
        }).join('\n');
        return `\n<div class="question" role="group" aria-labelledby="lbl-${qId}">\n  <p id="lbl-${qId}"><span class="qnum">Q${qNum}.</span> ${text}</p>\n${optionsHtml}\n  <div class="answer hidden" id="ans-${qId}" aria-live="polite"></div>\n</div>`;
      }
      function createShortQuestion(qId, text){
        const qNum = qId.replace(/^q/, '');
        const inId = `${qId}-txt`;
        return `\n<div class="question" role="group" aria-labelledby="lbl-${qId}">\n  <p id="lbl-${qId}"><span class="qnum">Q${qNum}.</span> ${text}</p>\n  <input id="${inId}" type="text" name="${qId}" style="width:100%" aria-describedby="ans-${qId}">\n  <div class="answer hidden" id="ans-${qId}" aria-live="polite"></div>\n</div>`;
      }
      function createBlanksQuestion(qId, text){
        // Replace each occurrence of ___ with a text input
        let idx = 1;
        const replaced = text.replace(/_{3,}/g, () => {
          const name = `${qId}-b${idx}`;
          const inId = `${qId}-b${idx}-id`;
          const html = `<span class="blank-wrap"><input id="${inId}" type="text" class="blank" name="${name}" style="min-width:120px" aria-describedby="ans-${qId}"></span>`;
          idx += 1;
          return html;
        });
        const qNum = qId.replace(/^q/, '');
        return `\n<div class="question" role="group" aria-labelledby="lbl-${qId}">\n  <p id="lbl-${qId}"><span class="qnum">Q${qNum}.</span> ${replaced}</p>\n  <div class="answer hidden" id="ans-${qId}" aria-live="polite"></div>\n</div>`;
      }
            // If plain-text sources exist, render questions from them for easy editing
            function renderFromPlainText(formId, sourceId, type){
              const sourceEl = document.getElementById(sourceId);
              const form = document.getElementById(formId);
              if (!sourceEl || !form) return false;
              // Prevent double rendering of the same form
              if (form.dataset.rendered === '1') return true;
              const raw = (sourceEl.textContent || '').trim();
              if (!raw) return false;
              const lines = raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
              // Strip Q#: and A#: prefixes from lines
              const cleanedLines = lines.map(line => line.replace(/^[QA]\d+:\s*/, ''));
              if (!cleanedLines.length) return false;
              // Preserve header, progress, actions
              const headerHtml = form.querySelector('h2')?.outerHTML || '';
              const progressHtml = form.querySelector('.progress')?.outerHTML || '';
              const actionsEl = form.querySelector('.form-actions');
              let html = `${headerHtml}\n${progressHtml}`;
              
              let qNum = 0;
              let skipNext = false;
              for (let i = 0; i < cleanedLines.length; i++) {
                if (skipNext) {
                  skipNext = false;
                  continue;
                }
                const text = cleanedLines[i];
                // Check if this line contains question options (has multiple | separators)
                const pipeCount = (text.match(/\|/g) || []).length;
                
                // Determine question line by type
                const hasBlanks = /_{3,}/.test(text);
                const isQuestion = (type === 'choice' && pipeCount >= 1)
                                  || (type === 'text' && pipeCount === 0 && text.length > 0)
                                  || (type === 'blanks' && hasBlanks);
                
                if (isQuestion) {
                  // This is a question line
                  qNum++;
                  const qId = `q${qNum}`;
                  
                  if (type === 'choice'){
                    const parts = text.split('|').map(s => s.trim()).filter(Boolean);
                    const questionText = parts[0] || text;
                    const optsRaw = parts.slice(1);
                    const opts = optsRaw.length ? optsRaw : ['True','False'];
                    
                    html += opts.length === 2 && opts[0]==='True' && opts[1]==='False'
                      ? createTFQuestion(qId, questionText)
                      : createMCQuestion(qId, questionText, opts);
                    
                    // Check next line for answer
                    if (i + 1 < cleanedLines.length) {
                      const nextLine = cleanedLines[i + 1];
                      const nextPipeCount = (nextLine.match(/\|/g) || []).length;
                      // If next line has 1 pipe, it's the answer line
                      if (nextPipeCount === 1) {
                        const answerParts = nextLine.split('|').map(s => s.trim());
                        if (answerParts.length === 2) {
                          answers[qId] = answerParts[0] + ' | ' + answerParts[1];
                          skipNext = true; // Skip the answer line in next iteration
                        }
                      }
                    }
                  } else if (type === 'text') {
                    // Short answer question
                    html += createShortQuestion(qId, text);
                    // Check next line for answer
                    if (i + 1 < cleanedLines.length) {
                      const nextLine = cleanedLines[i + 1];
                      // Next line with content is the answer
                      if (nextLine.trim().length > 0) {
                        shortAnswerKey[qId] = nextLine;
                        skipNext = true; // Skip the answer line
                      }
                    }
                  } else if (type === 'blanks') {
                    // Fill-in-the-blanks question: text contains ___ placeholders
                    html += createBlanksQuestion(qId, text);
                    if (i + 1 < cleanedLines.length) {
                      const nextLine = cleanedLines[i + 1];
                      const parts = nextLine.split('|').map(s => s.trim());
                      // Count blanks to map expected answers
                      const blanksCount = (text.match(/_{3,}/g) || []).length;
                      if (parts.length >= blanksCount) {
                        const answersArr = parts.slice(0, blanksCount);
                        const explanation = parts.slice(blanksCount).join('|').trim();
                        blanksAnswerKey[qId] = { answers: answersArr, explanation };
                        skipNext = true;
                      }
                    }
                  }
                }
              }
              
              html += `\n${actionsEl ? actionsEl.outerHTML : ''}`;
              form.innerHTML = html;
              // Mark as rendered to avoid duplicates on subsequent calls
              form.dataset.rendered = '1';
              return true;
            }

            // Try to render from text sources; fallback to existing markup if not present
            // If sourceA is empty, extract Test A questions from existing HTML and collapse markup
            function migrateTestAIfNeeded(){
              const srcA = document.getElementById('sourceA');
              if (!srcA) return;
              const hasContent = (srcA.textContent||'').trim().length > 0;
              if (hasContent) return;
              const formA = document.getElementById('testA');
              if (!formA) return;
              const qEls = Array.from(formA.querySelectorAll('.question'));
              if (!qEls.length) return;
              const lines = qEls.map(q => {
                const text = (q.querySelector('p')?.textContent || '').replace(/^\s*\d+\.?\s*/, '').trim();
                const radios = Array.from(q.querySelectorAll('input[type="radio"]'));
                if (radios.length){
                  const opts = radios.map(r => (r.value||'').trim());
                  return [text, ...opts].join(' | ');
                } else {
                  return text;
                }
              });
              srcA.textContent = lines.join('\n');
            }
            migrateTestAIfNeeded();
            // Minimize both forms, then render from sources to remove static markup
            (function(){
              const formIds = ['testA','testB','testC'];
              formIds.forEach(fid => {
                const form = document.getElementById(fid);
                if (!form) return;
                const headerHtml = form.querySelector('h2')?.outerHTML || '';
                const progressHtml = form.querySelector('.progress')?.outerHTML || '';
                const actionsHtml = form.querySelector('.form-actions')?.outerHTML || '';
                form.innerHTML = `${headerHtml}\n${progressHtml}\n${actionsHtml}`;
              });
            })();
            renderFromPlainText('testA','sourceA','choice');
            renderFromPlainText('testB','sourceB','text');
            renderFromPlainText('testC','sourceC','blanks');
      
      // Use event delegation on document to catch all button clicks
      document.addEventListener('click', function(e) {
        const target = e.target;
        
        if (target.id === 'btnSubmitA' || target.closest('#btnSubmitA')) {
          e.preventDefault();
          e.stopPropagation();
          submitTest('A');
          return false;
        }
        
        if (target.id === 'btnSubmitB' || target.closest('#btnSubmitB')) {
          e.preventDefault();
          e.stopPropagation();
          submitTest('B');
          return false;
        }
        if (target.id === 'btnSubmitC' || target.closest('#btnSubmitC')) {
          e.preventDefault();
          e.stopPropagation();
          submitTest('C');
          return false;
        }
        // Clear current question buttons
        function clearCurrentQuestion(formId){
          const form = document.getElementById(formId);
          if (!form) return;
          const idx = window.currentIndex ? window.currentIndex[formId] : 0;
          const questions = Array.from(form.querySelectorAll('.question'));
          const q = questions[idx];
          if (!q) return;
          // Clear radios and text inputs
          q.querySelectorAll('input[type="radio"]').forEach(r => { r.checked = false; });
          q.querySelectorAll('input[type="text"]').forEach(t => { t.value = ''; });
          // Hide any answer feedback
          const ansDiv = q.querySelector('.answer');
          if (ansDiv){ ansDiv.classList.add('hidden'); ansDiv.style.display='none'; ansDiv.textContent=''; }
        }
        if (target.id === 'btnResetB' || target.closest('#btnResetB')) { e.preventDefault(); clearCurrentQuestion('testB'); return false; }
        if (target.id === 'btnResetC' || target.closest('#btnResetC')) { e.preventDefault(); clearCurrentQuestion('testC'); return false; }
      }, true); // Use capture phase
      
      // Removed toggle bar start buttons
      // Intro page start buttons
      const startA = document.getElementById('startTestA');
      if (startA) startA.addEventListener('click', function(){ toggleTest('A'); });
      const startB = document.getElementById('startTestB');
      if (startB) startB.addEventListener('click', function(){ toggleTest('B'); });
      const startC = document.getElementById('startTestC');
      if (startC) startC.addEventListener('click', function(){ toggleTest('C'); });
      // Results page button
      const btnTryAgain = document.getElementById('btnTryAgain');
      if (btnTryAgain) btnTryAgain.addEventListener('click', function() {
        location.reload();
      });

      // Disable Esc behavior on results page
      const resultsPage = document.getElementById('resultsPage');
      if (resultsPage) {
        resultsPage.addEventListener('keydown', function(ev){
          if (ev.key === 'Escape') {
            ev.preventDefault();
            ev.stopPropagation();
          }
        });
      }

      // Paging: show one question at a time per form
      const currentIndex = { testA: 0, testB: 0, testC: 0 };
      const autoAdvance = false; // auto-advance disabled: user must press Next to continue

      function showQuestion(formId, index){
        const form = document.getElementById(formId);
        if (!form) return;
        const questions = Array.from(form.querySelectorAll('.question'));
        const total = questions.length;
        if (!total) return;
        if (index < 0) index = 0;
        if (index >= total) index = total - 1;
        currentIndex[formId] = index;
        questions.forEach((q,i) => q.style.display = (i === index ? '' : 'none'));
        const prev = document.getElementById(formId === 'testA' ? 'btnPrevA' : (formId === 'testB' ? 'btnPrevB' : 'btnPrevC'));
        const next = document.getElementById(formId === 'testA' ? 'btnNextA' : (formId === 'testB' ? 'btnNextB' : 'btnNextC'));
        const check = document.getElementById(formId === 'testA' ? 'btnCheckA' : (formId === 'testB' ? 'btnCheckB' : 'btnCheckC'));
        const isLast = index === total - 1;
        if (prev) { prev.disabled = index === 0; prev.onclick = function(){ prevQuestion(formId); }; }
        if (next) {
          next.textContent = 'Next';
          next.onclick = function(){ nextQuestion(formId); };
          next.disabled = isLast;
        }
          if (check) {
              check.style.display = isLast ? 'none' : '';
              // Set initial label based on current question's answer visibility
              const current = questions[index];
              const ansDiv = current ? current.querySelector('.answer') : null;
              const isShown = ansDiv && !ansDiv.classList.contains('hidden') && ansDiv.style.display !== 'none' && ansDiv.textContent.trim() !== '';
              check.textContent = isShown ? 'Hide Answer' : 'Show Answer';
              check.onclick = function(){
                // Recompute current visibility at click time
                const currentQ = questions[currentIndex[formId]];
                const aDiv = currentQ ? currentQ.querySelector('.answer') : null;
                const visible = aDiv && !aDiv.classList.contains('hidden') && aDiv.style.display !== 'none' && aDiv.textContent.trim() !== '';
                const nowShown = toggleAnswer(formId, !visible);
                // Update button label after action
                check.textContent = nowShown ? 'Hide Answer' : 'Show Answer';
              };
            }
        const submitBtn = document.getElementById(formId === 'testA' ? 'btnSubmitA' : (formId === 'testB' ? 'btnSubmitB' : 'btnSubmitC'));
        if (submitBtn) {
          submitBtn.style.display = isLast ? '' : 'none';
          submitBtn.disabled = false;
        }
        // progress bar
        const suffix = formId === 'testA' ? 'A' : (formId === 'testB' ? 'B' : 'C');
        const progressFill = document.getElementById('progressFill' + suffix);
        const progressText = document.getElementById('progressText' + suffix);
        const pct = total > 0 ? Math.round(((index+1)/total) * 100) : 0;
        if (progressFill) progressFill.style.width = pct + '%';
        if (progressText) progressText.textContent = `${index+1} / ${total}`;
        // Auto-focus first control for current question (debounced, prevent scroll)
        const current = questions[index];
        const firstControl = current ? (current.querySelector('input.blank, input[type="radio"], input[type="text"]')) : null;
        if (firstControl) {
          clearTimeout(showQuestion._ft || 0);
          showQuestion._ft = setTimeout(() => {
            try { firstControl.focus({ preventScroll: true }); } catch(_) { firstControl.focus(); }
          }, 0);
        }
      }
      // Expose paging helpers for global calls (e.g., from toggleTest)
      window.currentIndex = currentIndex;
      window.showQuestion = showQuestion;

      function prevQuestion(formId) {
        const idx = currentIndex[formId];
        const newIdx = Math.max(0, idx - 1);
        showQuestion(formId, newIdx);
      }

      function nextQuestion(formId) {
        const form = document.getElementById(formId);
        const questions = Array.from(form.querySelectorAll('.question'));
        const idx = currentIndex[formId];
        const newIdx = Math.min(questions.length - 1, idx + 1);
        showQuestion(formId, newIdx);
      }

      function checkQuestion(formId) {
        // Legacy: kept for Enter key mapping; now delegates to show suggested answer
        toggleAnswer(formId, true);
      }

      function toggleAnswer(formId, show){
        // Show or hide the suggested/correct answer for the current question
        const form = document.getElementById(formId);
        const idx = currentIndex[formId];
        const questions = Array.from(form.querySelectorAll('.question'));
        const q = questions[idx];
        if (!q) return;
        const ansDiv = q.querySelector('.answer');
        const firstInput = q.querySelector('input');
        const inputName = firstInput ? firstInput.name : null;
        let correctAnswer = null;
        let explanation = '';
        let isBlanks = (formId === 'testC');
        let expected = [];
        if (isBlanks) {
          const baseName = inputName ? String(inputName).split('-')[0] : null;
          const entry = baseName ? blanksAnswerKey[baseName] : null;
          if (entry) {
            expected = Array.isArray(entry.answers) ? entry.answers : [];
            correctAnswer = expected.join(', ');
            explanation = entry.explanation || '';
          }
        } else {
          const rawAnswer = formId === 'testB' ? shortAnswerKey[inputName] : answers[inputName];
          correctAnswer = rawAnswer ? String(rawAnswer).split('|')[0].trim() : null;
          if (rawAnswer) {
            const parts = String(rawAnswer).split('|');
            explanation = parts.length > 1 ? parts.slice(1).join('|').trim() : (formId === 'testB' ? String(rawAnswer).trim() : '');
          }
        }
        if (!ansDiv) return false;
        if (show) {
          const isChoice = !!q.querySelector('input[type="radio"]');
          const isText = !isChoice && !isBlanks;
          if (isBlanks) {
            ansDiv.textContent = "Suggested Answers: " + (expected.length ? expected.join(', ') : (correctAnswer || '')) + (explanation ? " â€” " + explanation : "");
          } else if (isText) {
            ansDiv.textContent = "Suggested Answer: " + (correctAnswer || "") + (explanation ? " â€” " + explanation : "");
          } else {
            ansDiv.textContent = "Correct Answer: " + (correctAnswer || "") + (explanation ? " â€” " + explanation : "");
          }
          ansDiv.className = "answer";
          ansDiv.classList.remove('hidden'); ansDiv.style.display = 'block';
          return true;
        } else {
          ansDiv.classList.add('hidden'); ansDiv.style.display='none'; ansDiv.textContent='';
          return false;
        }
      }

      function initPagingFor(id) {
        const form = document.getElementById(id);
        if (!form) return;
        let questions = Array.from(form.querySelectorAll('.question'));
        // Dedupe any accidental duplicate question cards (same text)
        const seen = new Set();
        questions.forEach(q => {
          const t = (q.querySelector('p')?.textContent || '').trim();
          if (t && seen.has(t)) { q.remove(); }
          else if (t) { seen.add(t); }
        });
        // Refresh questions list after possible removals
        questions = Array.from(form.querySelectorAll('.question'));
        // 1) Strip leading numbers from question text (e.g., "1. ")
        //    Skip questions that contain inputs (e.g., Medium blanks) to avoid removing the inputs.
        questions.forEach(q => {
          const p = q.querySelector('p');
          if (!p) return;
          const hasInputs = !!p.querySelector('input');
          if (hasInputs) return; // keep blanks inputs intact
          p.textContent = (p.textContent || '').replace(/^\s*\d+\.?\s*/, '');
        });
        // 2) Randomize and select a subset of 10 questions
        const shuffled = questions.map(q => ({ q, sort: Math.random() }))
                                  .sort((a,b) => a.sort - b.sort)
                                  .map(({q}) => q);
        const subset = shuffled.slice(0, 10);
        const actions = form.querySelector('.form-actions');
        // Remove non-selected questions from DOM
        questions.forEach(q => { if (!subset.includes(q)) q.remove(); });
        // Append selected in chosen order
        subset.forEach(q => form.insertBefore(q, actions));
        // hide all initially
        subset.forEach(q => q.style.display = 'none');
        // show first
        showQuestion(id, 0);
        // Keyboard shortcuts: N for Next, C for Check, Enter -> Check
        // Toast utility
        const toastEl = document.getElementById('shortcutToast');
        let toastTimer = null;
        function showToast(msg){
          if (!toastEl) return;
          toastEl.textContent = msg;
          toastEl.classList.add('show');
          clearTimeout(toastTimer);
          toastTimer = setTimeout(() => { toastEl.classList.remove('show'); }, 1200);
        }

        form.addEventListener('keydown', function(ev){
          const key = ev.key.toLowerCase();
          if (key === 'n') { ev.preventDefault(); nextQuestion(id); showToast('Next'); }
          if (key === 'p') { ev.preventDefault(); prevQuestion(id); showToast('Prev'); }
          if (ev.key === 'ArrowRight') { ev.preventDefault(); nextQuestion(id); showToast('Next'); }
          if (ev.key === 'ArrowLeft') { ev.preventDefault(); prevQuestion(id); showToast('Prev'); }
          if (ev.key === 'ArrowUp') { ev.preventDefault();
            const shown = toggleAnswer(id, true);
            // Sync button label
            const btn = document.getElementById(id === 'testA' ? 'btnCheckA' : (id === 'testB' ? 'btnCheckB' : 'btnCheckC'));
            if (btn) btn.textContent = shown ? 'Hide Answer' : 'Show Answer';
            showToast('Show Answer');
          }
          // Remove Right Control shortcut per request
          if (ev.key === 'ArrowDown') { ev.preventDefault();
            const shown = toggleAnswer(id, false);
            const btn = document.getElementById(id === 'testA' ? 'btnCheckA' : (id === 'testB' ? 'btnCheckB' : 'btnCheckC'));
            if (btn) btn.textContent = shown ? 'Hide Answer' : 'Show Answer';
            showToast('Hide Answer');
          }
          if (ev.key === 'Escape') { ev.preventDefault();
            // Scope Esc clear to Hard/Medium only
            if (id !== 'testA') {
              const idx = window.currentIndex ? window.currentIndex[id] : 0;
              const q = form.querySelectorAll('.question')[idx];
              if (q) {
                q.querySelectorAll('input[type="radio"]').forEach(r => { r.checked = false; });
                q.querySelectorAll('input[type="text"]').forEach(t => { t.value = ''; });
                const ansDiv = q.querySelector('.answer');
                if (ansDiv){ ansDiv.classList.add('hidden'); ansDiv.style.display='none'; ansDiv.textContent=''; }
              }
              showToast('Cleared');
            }
          }
          if (key === 'enter'){
            const active = document.activeElement;
            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')){
              ev.preventDefault();
              // Enter shows answer for quick reference
              const shown = toggleAnswer(id, true);
              const btn = document.getElementById(id === 'testA' ? 'btnCheckA' : (id === 'testB' ? 'btnCheckB' : 'btnCheckC'));
              if (btn) btn.textContent = shown ? 'Hide Answer' : 'Show Answer';
              showToast('Show Answer');
            }
          }
        });
        // Clickable progress text to open quick navigator (simple prompt)
        const suffix = id === 'testA' ? 'A' : (id === 'testB' ? 'B' : 'C');
        const pText = document.getElementById('progressText' + suffix);
        if (pText) {
          pText.style.cursor = 'pointer';
          pText.title = 'Jump to question';
          pText.onclick = function(){
            const total = form.querySelectorAll('.question').length;
            const ans = prompt(`Enter question number (1-${total})`);
            const num = parseInt(ans||'', 10);
            if (!isNaN(num) && num >= 1 && num <= total) showQuestion(id, num-1);
          };
        }
      }

      function initPaging() {
        initPagingFor('testA');
        initPagingFor('testB');
        initPagingFor('testC');
      }

      // Remove show-answer buttons since we validate/correct before advancing
      document.querySelectorAll('.show-answer-btn').forEach(b => b.remove());

      initPaging();

      // Responsive, edge-aware tooltip for keyboard shortcuts; click-to-toggle on mobile
      (function(){
        const helps = document.querySelectorAll('.help-shortcuts');
        function positionPopover(btn){
          const pop = btn.querySelector('.popover');
          if (!pop) return;
          // responsive width
          pop.style.maxWidth = 'min(90vw, 480px)';
          const rect = btn.getBoundingClientRect();
          const popW = Math.min(480, Math.floor(window.innerWidth * 0.9));
          const spaceRight = window.innerWidth - rect.right;
          if (spaceRight < popW + 16) {
            pop.style.right = 'auto';
            pop.style.left = '0';
          } else {
            pop.style.left = 'auto';
            pop.style.right = '10px';
          }
        }
        helps.forEach(btn => {
          const pop = btn.querySelector('.popover');
          if (!pop) return;
          ['mouseenter','focus'].forEach(ev => btn.addEventListener(ev, () => positionPopover(btn)));
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const open = btn.classList.toggle('open');
            btn.setAttribute('aria-expanded', open ? 'true' : 'false');
            positionPopover(btn);
          });
        });
        document.addEventListener('click', (e) => {
          document.querySelectorAll('.help-shortcuts.open').forEach(btn => {
            if (!btn.contains(e.target)) {
              btn.classList.remove('open');
              btn.setAttribute('aria-expanded', 'false');
            }
          });
        });
        window.addEventListener('resize', () => {
          document.querySelectorAll('.help-shortcuts').forEach(positionPopover);
        });
      })();

      // Ensure the translucent backdrop covers the full page height (not just the viewport)
      const backdrop = document.querySelector('.card-backdrop');
      const page = document.querySelector('.page');
      function updateBackdrop(){
        if (!backdrop || !page) return;
        const rect = page.getBoundingClientRect();
        // page offset relative to document
        const pageTop = page.offsetTop;
        backdrop.style.position = 'absolute';
        backdrop.style.left = (rect.left + window.pageXOffset) + 'px';
        backdrop.style.top = pageTop + 'px';
        backdrop.style.width = rect.width + 'px';
        backdrop.style.height = page.offsetHeight + 'px';
        backdrop.style.transform = 'none';
      }
      updateBackdrop();
      window.addEventListener('resize', updateBackdrop);
      // also update after a short delay in case fonts/images change layout
      setTimeout(updateBackdrop, 500);
      // Watch for layout changes (content added/removed) and update backdrop
      const observer = new MutationObserver(updateBackdrop);
      observer.observe(page, { childList: true, subtree: true, attributes: true, attributeFilter: ['style','class'] });
      // Expose a global hook so other functions can force an update
      window.requestBackdropUpdate = updateBackdrop;

      // Helper to rebuild questions from plain text and reinitialize paging for a test
      window.rerandomizeTest = function(test){
        const formId = test === 'A' ? 'testA' : (test === 'B' ? 'testB' : 'testC');
        const sourceId = test === 'A' ? 'sourceA' : (test === 'B' ? 'sourceB' : 'sourceC');
        const type = test === 'A' ? 'choice' : (test === 'B' ? 'text' : 'blanks');
        const form = document.getElementById(formId);
        if (!form) return;
        // Clear answer maps for the given test type
        if (type === 'choice') {
          for (const k in answers) delete answers[k];
        } else if (type === 'text') {
          for (const k in shortAnswerKey) delete shortAnswerKey[k];
        } else if (type === 'blanks') {
          for (const k in blanksAnswerKey) delete blanksAnswerKey[k];
        }
        // Reset form content to header + progress + actions to avoid accumulating DOM
        const headerHtml = form.querySelector('h2')?.outerHTML || '';
        const progressHtml = form.querySelector('.progress')?.outerHTML || '';
        const actionsHtml = form.querySelector('.form-actions')?.outerHTML || '';
        form.innerHTML = `${headerHtml}\n${progressHtml}\n${actionsHtml}`;
        // Allow render again
        delete form.dataset.rendered;
        // Render from sources and reinit paging
        renderFromPlainText(formId, sourceId, type);
        initPagingFor(formId);
        // Focus first question on start
        const questions = form.querySelectorAll('.question');
        if (questions.length) {
          setTimeout(() => {
            try {
              const firstControl = questions[0].querySelector('input.blank, input[type="radio"], input[type="text"]');
              if (firstControl) firstControl.focus({ preventScroll: true });
            } catch(_) {}
          }, 0);
        }
      };
    });
  </script>
  </div>
</body>
</html>
